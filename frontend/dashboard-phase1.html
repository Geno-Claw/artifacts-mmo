<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Artifacts MMO Bot Manager — Sumi-e Ink Wash</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
/* ============================================================
   SAKURA GARDEN — SUMI-E INK WASH VARIANT
   Handmade washi paper + ink painting aesthetic
   ============================================================ */
*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  image-rendering: pixelated;
  -ms-interpolation-mode: nearest-neighbor;
}

:root {
  --paper: #f4ece0;
  --paper-warm: #f0e8d8;
  --paper-dark: #e8dcc8;
  --ink: #2a2420;
  --ink-light: #584840;
  --ink-faint: #8a7868;
  --ink-ghost: rgba(42, 36, 32, 0.08);
  --vermillion: #c83028;
  --vermillion-dark: #a02820;
  --vermillion-light: #e04838;
  --indigo: #384878;
  --indigo-light: #506090;
  --ink-track: #3a3430;
  --ready-green: #607848;
  --petal-pink: #d88898;
  --petal-light: #e8a8b0;
  --petal-gray: #a09890;
  --petal-gray-light: #b8b0a8;
  --brush-dark: #382c28;
  --branch-ink: #483830;
  --branch-mid: #685848;
  --blossom-yellow: #c8a850;
}

html {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  color: var(--ink);
  background: var(--paper);
}

body {
  min-height: 100vh;
  /* Washi paper texture — layered noise simulation */
  background:
    /* Fine fiber grain */
    repeating-linear-gradient(
      87deg,
      transparent 0px,
      transparent 2px,
      rgba(42, 36, 32, 0.012) 2px,
      rgba(42, 36, 32, 0.012) 3px
    ),
    repeating-linear-gradient(
      177deg,
      transparent 0px,
      transparent 3px,
      rgba(42, 36, 32, 0.008) 3px,
      rgba(42, 36, 32, 0.008) 4px
    ),
    /* Warm paper gradient — subtle tea stain effect */
    radial-gradient(ellipse at 30% 20%, rgba(200, 168, 120, 0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 80%, rgba(180, 148, 100, 0.06) 0%, transparent 50%),
    linear-gradient(180deg, #f2e8d8 0%, var(--paper) 30%, #f0e4d4 70%, #ecdcc8 100%);
  overflow-x: hidden;
  position: relative;
}

body.modal-open {
  overflow: hidden;
}

/* Additional paper fiber texture overlay */
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  /* Organic dot pattern — like paper fibers */
  background-image:
    radial-gradient(circle, rgba(42, 36, 32, 0.04) 0.5px, transparent 0.5px),
    radial-gradient(circle, rgba(42, 36, 32, 0.03) 0.3px, transparent 0.3px);
  background-size: 11px 13px, 7px 9px;
  background-position: 0 0, 4px 5px;
  pointer-events: none;
  z-index: 0;
}

/* ============================================================
   PETAL + INK DROP ANIMATION
   ============================================================ */
.petals-container {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 1;
  overflow: hidden;
}

.petal {
  position: absolute;
  opacity: 0;
  animation: petalFall linear infinite;
}

.petal--blossom {
  width: 4px;
  height: 4px;
}

.petal--ink {
  width: 2px;
  height: 2px;
  border-radius: 50%;
}

@keyframes petalFall {
  0% {
    opacity: 0;
    transform: translateY(-10px) translateX(0px) rotate(0deg);
  }
  5% {
    opacity: 0.6;
  }
  50% {
    opacity: 0.4;
  }
  95% {
    opacity: 0.2;
  }
  100% {
    opacity: 0;
    transform: translateY(100vh) translateX(60px) rotate(540deg);
  }
}

/* ============================================================
   HEADER
   ============================================================ */
.page-header {
  position: relative;
  z-index: 2;
  text-align: center;
  padding: 40px 16px 8px;
}

.page-header h1 {
  font-size: 14px;
  letter-spacing: 2px;
  color: var(--ink);
  text-shadow: 1px 1px 0 rgba(244, 236, 224, 0.8);
  margin-bottom: 6px;
}

.page-header .subtitle {
  font-size: 7px;
  color: var(--ink-faint);
  letter-spacing: 4px;
  text-transform: uppercase;
}

.dashboard-controls {
  position: relative;
  z-index: 2;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: center;
  padding: 2px 16px 14px;
}

.dashboard-control-btn {
  min-width: 94px;
}

.dashboard-control-btn[data-runtime-control] {
  min-width: 118px;
}

.dashboard-control-status {
  position: relative;
  z-index: 2;
  width: min(620px, calc(100vw - 32px));
  margin: 0 auto 10px;
  padding: 0 2px;
}

.dashboard-control-status-grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 6px;
}

.dashboard-control-status-value {
  text-transform: uppercase;
  letter-spacing: 1px;
  word-break: break-word;
}

.dashboard-control-status-value.is-error {
  color: #5a231e;
}

.dashboard-control-banner {
  position: relative;
  z-index: 2;
  width: min(620px, calc(100vw - 32px));
  margin: 0 auto 12px;
  font-size: 6px;
  line-height: 1.4;
  padding: 8px 12px;
  letter-spacing: 1px;
  border-left: 2px solid rgba(42, 36, 32, 0.18);
  background: rgba(42, 36, 32, 0.08);
  color: var(--ink);
}

.dashboard-control-banner.info {
  color: #2f4732;
  background: rgba(96, 120, 72, 0.14);
}

.dashboard-control-banner.success {
  color: #2f4732;
  background: rgba(96, 120, 72, 0.18);
}

.dashboard-control-banner.warning {
  color: #5a231e;
  background: rgba(200, 48, 40, 0.14);
}

.dashboard-control-banner.error {
  color: #5a231e;
  background: rgba(200, 48, 40, 0.18);
}

/* Brush stroke divider */
.divider {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin: 16px auto;
  max-width: 400px;
}

.divider-line {
  flex: 1;
  height: 1px;
  background: linear-gradient(90deg,
    transparent,
    rgba(42, 36, 32, 0.15) 10%,
    rgba(42, 36, 32, 0.4) 30%,
    rgba(42, 36, 32, 0.5) 50%,
    rgba(42, 36, 32, 0.4) 70%,
    rgba(42, 36, 32, 0.15) 90%,
    transparent);
  /* Uneven ink wash stroke feel */
  box-shadow:
    0 -1px 0 rgba(42, 36, 32, 0.05),
    0 1px 0 rgba(42, 36, 32, 0.08);
}

.divider-diamond {
  width: 6px;
  height: 6px;
  background: var(--vermillion);
  transform: rotate(45deg);
  box-shadow: 0 0 0 1px rgba(42, 36, 32, 0.3);
}

/* ============================================================
   CARDS CONTAINER
   ============================================================ */
.cards-container {
  position: relative;
  z-index: 2;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 24px;
  padding: 16px 24px 48px;
}

/* ============================================================
   CHARACTER CARD — rice paper sheet with brush stroke borders
   ============================================================ */
.card {
  width: 280px;
  background: var(--paper-warm);
  position: relative;
  padding: 0;
  /* Brush stroke borders — uneven thickness like a real brush */
  box-shadow:
    /* Top edge: thick brush start */
    0 -3px 0 0 var(--ink),
    /* Right edge: thin upstroke */
    1px 0 0 0 var(--ink),
    /* Bottom edge: medium pressure */
    0 2px 0 0 var(--ink),
    /* Left edge: thin-to-medium */
    -1px 0 0 0 var(--ink),
    /* Ink bleed / paper shadow */
    3px 4px 0 0 rgba(42, 36, 32, 0.06),
    -1px -1px 0 0 rgba(42, 36, 32, 0.03);
}

.card.offline {
  opacity: 0.72;
  filter: saturate(0.5);
}

/* Ink splatter at top-right corner */
.card::before {
  content: '';
  position: absolute;
  top: 6px;
  right: 8px;
  width: 3px;
  height: 3px;
  background: rgba(42, 36, 32, 0.15);
  border-radius: 50%;
  box-shadow:
    4px 2px 0 0 rgba(42, 36, 32, 0.1),
    -2px 4px 0 0 rgba(42, 36, 32, 0.08),
    6px 5px 0 0 rgba(42, 36, 32, 0.06),
    1px 6px 0 0 rgba(42, 36, 32, 0.12);
  pointer-events: none;
  z-index: 3;
}

/* Ink splatter at bottom-left corner */
.card::after {
  content: '';
  position: absolute;
  bottom: 10px;
  left: 10px;
  width: 2px;
  height: 2px;
  background: rgba(42, 36, 32, 0.12);
  border-radius: 50%;
  box-shadow:
    3px -1px 0 0 rgba(42, 36, 32, 0.09),
    -1px 3px 0 0 rgba(42, 36, 32, 0.07),
    5px 2px 0 0 rgba(42, 36, 32, 0.05);
  pointer-events: none;
  z-index: 3;
}

.card-inner {
  position: relative;
  z-index: 2;
  padding: 0 16px 16px;
}

/* ============================================================
   CHERRY BRANCH DECORATION (top of each card)
   ============================================================ */
.cherry-branch {
  position: relative;
  width: 100%;
  height: 40px;
  overflow: hidden;
  margin-bottom: 4px;
}

.cherry-branch canvas {
  display: block;
  width: 100%;
  height: 40px;
  image-rendering: pixelated;
}

/* ============================================================
   CHARACTER NAME — vermillion ink
   ============================================================ */
.char-name {
  text-align: center;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--vermillion);
  margin-bottom: 10px;
  text-shadow: 1px 1px 0 rgba(244, 236, 224, 0.6);
}

/* ============================================================
   PORTRAIT FRAME — ink border on paper
   ============================================================ */
.portrait-frame {
  display: flex;
  justify-content: center;
  margin-bottom: 12px;
}

.portrait-border {
  /* Brush stroke border — uneven like hand-drawn rectangle */
  box-shadow:
    0 -2px 0 0 var(--ink),
    2px 0 0 0 var(--ink),
    0 1px 0 0 var(--ink),
    -1px 0 0 0 var(--ink),
    2px 2px 0 0 rgba(42, 36, 32, 0.08);
  background: var(--paper-dark);
  padding: 3px;
  line-height: 0;
}

.portrait-border canvas {
  display: block;
  width: 96px;
  height: 96px;
  image-rendering: pixelated;
}

/* ============================================================
   LEVEL BADGE — hanko seal style
   ============================================================ */
.level-row {
  text-align: center;
  margin-bottom: 10px;
}

.level-badge {
  display: inline-block;
  font-size: 8px;
  color: var(--paper);
  background: var(--vermillion);
  border: none;
  padding: 4px 10px;
  letter-spacing: 1px;
  transform: rotate(-1deg);
  box-shadow:
    1px 1px 0 rgba(42, 36, 32, 0.15),
    inset 0 0 0 1px rgba(255, 255, 255, 0.1);
}

/* ============================================================
   STAT BARS (HP / XP) — ink wash style
   ============================================================ */
.stat-bars {
  margin-bottom: 10px;
}

.stat-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 5px;
}

.stat-label {
  font-size: 7px;
  width: 20px;
  text-align: right;
  color: var(--ink-faint);
  flex-shrink: 0;
}

.stat-bar-track {
  flex: 1;
  height: 8px;
  background: var(--ink-track);
  border: none;
  position: relative;
  overflow: hidden;
  box-shadow: 1px 1px 0 rgba(42, 36, 32, 0.1);
}

.stat-bar-track.xp-track {
  background: var(--ink-track);
}

.stat-bar-fill {
  height: 100%;
  background: var(--vermillion);
  transition: width 0.3s ease;
  position: relative;
}

/* Subtle ink shine on bar */
.stat-bar-fill::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: rgba(255, 255, 255, 0.2);
}

.stat-bar-fill.xp-fill {
  background: var(--indigo);
}

.stat-value {
  font-size: 6px;
  width: 62px;
  text-align: left;
  color: var(--ink-faint);
  flex-shrink: 0;
  white-space: nowrap;
}

/* ============================================================
   COOLDOWN TIMER
   ============================================================ */
.cooldown-section {
  margin-bottom: 10px;
}

.cooldown-label {
  font-size: 6px;
  color: var(--ink-faint);
  text-align: center;
  margin-bottom: 3px;
  letter-spacing: 1px;
}

.cooldown-bar-track {
  height: 10px;
  background: var(--paper-dark);
  border: 1px solid rgba(42, 36, 32, 0.25);
  position: relative;
  overflow: hidden;
  margin-bottom: 3px;
}

.cooldown-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--ink-faint), var(--ink-light));
  transition: width 0.1s linear;
  position: relative;
}

.cooldown-bar-fill::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: rgba(255, 255, 255, 0.15);
}

.cooldown-bar-fill.ready {
  background: var(--ready-green);
}

.cooldown-text {
  font-size: 9px;
  text-align: center;
  color: var(--ink);
  letter-spacing: 1px;
  min-height: 12px;
}

.cooldown-text.ready-flash {
  color: var(--ready-green);
  animation: readyPulse 0.3s ease-in-out infinite alternate;
}

@keyframes readyPulse {
  0% { opacity: 1; }
  100% { opacity: 0.4; }
}

/* ============================================================
   INFO PANELS — inset paper areas
   ============================================================ */
.info-panel {
  background: rgba(42, 36, 32, 0.03);
  border: none;
  border-left: 2px solid rgba(42, 36, 32, 0.12);
  border-bottom: 1px solid rgba(42, 36, 32, 0.06);
  padding: 6px 8px;
  margin-bottom: 8px;
  min-height: 30px;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.info-panel-label {
  font-size: 5px;
  color: var(--ink-faint);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 4px;
}

.info-panel-text {
  font-size: 7px;
  line-height: 1.6;
  color: var(--ink);
  word-break: break-word;
}

/* ============================================================
   ACTION BUTTONS — hanko seal / ink stamp style
   ============================================================ */
.buttons-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  margin-top: 4px;
}

.btn-row {
  display: flex;
  gap: 4px;
  justify-content: center;
}

.action-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  color: var(--paper);
  background: var(--vermillion);
  border: none;
  padding: 5px 6px;
  cursor: pointer;
  letter-spacing: 0.5px;
  box-shadow:
    1px 1px 0 rgba(42, 36, 32, 0.2);
  transition: none;
  line-height: 1;
  white-space: nowrap;
}

/* Slight rotation on each button — hand-stamped feel */
.btn-row:nth-child(1) .action-btn:nth-child(1) { transform: rotate(-1.2deg); }
.btn-row:nth-child(1) .action-btn:nth-child(2) { transform: rotate(0.8deg); }
.btn-row:nth-child(2) .action-btn:nth-child(1) { transform: rotate(1.5deg); }
.btn-row:nth-child(3) .action-btn:nth-child(1) { transform: rotate(-0.5deg); }
.btn-row:nth-child(3) .action-btn:nth-child(2) { transform: rotate(1.8deg); }

.action-btn:hover {
  background: var(--vermillion-light);
}

.action-btn:active {
  background: var(--vermillion-dark);
  color: var(--paper);
  box-shadow:
    inset 1px 1px 0 rgba(0, 0, 0, 0.3);
}

.action-btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

/* ============================================================
   MODAL FRAMEWORK — character details
   ============================================================ */
.modal-host {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 24;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
}

.modal-host[hidden] {
  display: none;
}

.modal-scrim {
  position: absolute;
  inset: 0;
  background: rgba(42, 36, 32, 0.52);
}

.character-modal {
  position: relative;
  z-index: 1;
  width: min(720px, calc(100vw - 22px));
  max-height: calc(100vh - 28px);
  background: var(--paper-warm);
  display: flex;
  flex-direction: column;
  box-shadow:
    0 -3px 0 0 var(--ink),
    2px 0 0 0 var(--ink),
    0 2px 0 0 var(--ink),
    -1px 0 0 0 var(--ink),
    5px 7px 0 0 rgba(42, 36, 32, 0.18);
  outline: none;
}

.modal-header {
  border-bottom: 1px solid rgba(42, 36, 32, 0.2);
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.26), rgba(42, 36, 32, 0.02));
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 12px;
}

.modal-kind {
  font-size: 6px;
  letter-spacing: 2px;
  color: var(--ink-faint);
  text-transform: uppercase;
}

.modal-title {
  margin-top: 5px;
  font-size: 9px;
  letter-spacing: 1px;
  color: var(--vermillion);
}

.modal-close {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  color: var(--paper);
  background: var(--ink);
  border: none;
  padding: 6px 8px;
  line-height: 1;
  cursor: pointer;
  box-shadow: 1px 1px 0 rgba(42, 36, 32, 0.22);
}

.modal-close:hover {
  background: var(--ink-light);
}

.modal-banner {
  font-size: 6px;
  line-height: 1.4;
  padding: 8px 12px;
  letter-spacing: 1px;
  border-bottom: 1px solid rgba(42, 36, 32, 0.15);
}

.modal-banner.offline {
  color: #5a231e;
  background: rgba(200, 48, 40, 0.12);
}

.modal-banner.stale {
  color: #3f4732;
  background: rgba(96, 120, 72, 0.14);
}

.modal-banner.success {
  color: #2f4732;
  background: rgba(96, 120, 72, 0.18);
}

.modal-banner.warning {
  color: #5a231e;
  background: rgba(200, 48, 40, 0.14);
}

.modal-banner.error {
  color: #5a231e;
  background: rgba(200, 48, 40, 0.18);
}

.modal-content {
  overflow: auto;
  padding: 12px;
}

.modal-state,
.modal-empty,
.modal-error {
  padding: 12px;
  background: rgba(42, 36, 32, 0.04);
  border-left: 2px solid rgba(42, 36, 32, 0.16);
  line-height: 1.7;
  font-size: 7px;
}

.modal-error {
  border-left-color: rgba(200, 48, 40, 0.5);
  color: #5a231e;
}

.modal-section {
  margin-bottom: 12px;
}

.modal-section:last-child {
  margin-bottom: 0;
}

.modal-section-title {
  font-size: 6px;
  letter-spacing: 2px;
  color: var(--ink-faint);
  margin-bottom: 6px;
}

.modal-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.modal-stat {
  background: rgba(42, 36, 32, 0.03);
  border-left: 2px solid rgba(42, 36, 32, 0.12);
  padding: 6px;
}

.modal-stat-label {
  font-size: 5px;
  letter-spacing: 1px;
  color: var(--ink-faint);
  margin-bottom: 5px;
  text-transform: uppercase;
}

.modal-stat-value {
  font-size: 7px;
  color: var(--ink);
  line-height: 1.5;
  word-break: break-word;
}

.modal-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.modal-list-item {
  display: grid;
  grid-template-columns: 1fr auto auto;
  align-items: center;
  gap: 8px;
  padding: 7px 8px;
  background: rgba(42, 36, 32, 0.03);
  border-left: 2px solid rgba(42, 36, 32, 0.12);
  font-size: 7px;
  line-height: 1.5;
}

.modal-list-item--two {
  grid-template-columns: 1fr auto;
}

.modal-list-main {
  color: var(--ink);
  word-break: break-word;
}

.modal-list-tag,
.modal-list-slot {
  color: var(--ink-faint);
  font-size: 6px;
}

.modal-log-line {
  display: block;
  margin-top: 3px;
  color: var(--ink);
}

.achievement-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  justify-content: space-between;
}

.achievement-filter-group {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.achievement-filter-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  color: var(--ink);
  background: rgba(42, 36, 32, 0.05);
  border: none;
  padding: 5px 7px;
  cursor: pointer;
  line-height: 1;
  box-shadow: 1px 1px 0 rgba(42, 36, 32, 0.15);
}

.achievement-filter-btn:hover {
  background: rgba(42, 36, 32, 0.1);
}

.achievement-filter-btn.is-active {
  color: var(--paper);
  background: var(--ink);
}

.achievement-search {
  display: flex;
  align-items: center;
  gap: 6px;
}

.achievement-search-label {
  font-size: 5px;
  letter-spacing: 1px;
  color: var(--ink-faint);
}

.achievement-search-input {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  color: var(--ink);
  background: rgba(255, 255, 255, 0.45);
  border: none;
  min-width: 170px;
  padding: 6px 7px;
  box-shadow:
    inset 0 0 0 1px rgba(42, 36, 32, 0.18),
    1px 1px 0 rgba(42, 36, 32, 0.08);
}

.achievement-search-input:focus {
  outline: none;
  box-shadow:
    inset 0 0 0 1px var(--ink),
    1px 1px 0 rgba(42, 36, 32, 0.08);
}

.achievement-result-count {
  margin-top: 8px;
  font-size: 6px;
  line-height: 1.5;
  letter-spacing: 1px;
  color: var(--ink-faint);
}

.achievement-list-main {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.achievement-code {
  color: var(--vermillion);
}

.achievement-title {
  color: var(--ink);
  font-size: 6px;
  line-height: 1.4;
}

.achievement-progress {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 3px;
}

.achievement-status {
  font-size: 6px;
  letter-spacing: 1px;
}

.achievement-status.is-completed {
  color: var(--ready-green);
}

.achievement-status.is-in-progress {
  color: var(--indigo);
}

.achievement-status.is-not-started {
  color: var(--ink-faint);
}

.config-editor {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.config-editor-meta {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.config-editor-meta .modal-stat {
  min-height: 40px;
}

.config-editor-textarea {
  width: 100%;
  min-height: 260px;
  resize: vertical;
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  line-height: 1.6;
  color: var(--ink);
  background: rgba(255, 255, 255, 0.45);
  border: none;
  padding: 10px;
  box-shadow:
    inset 0 0 0 1px rgba(42, 36, 32, 0.18),
    1px 1px 0 rgba(42, 36, 32, 0.08);
}

.config-editor-textarea:focus {
  outline: none;
  box-shadow:
    inset 0 0 0 1px var(--ink),
    1px 1px 0 rgba(42, 36, 32, 0.08);
}

.config-editor-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.config-editor-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  color: var(--paper);
  background: var(--ink);
  border: none;
  padding: 6px 9px;
  line-height: 1;
  cursor: pointer;
  box-shadow: 1px 1px 0 rgba(42, 36, 32, 0.22);
}

.config-editor-btn:hover {
  background: var(--ink-light);
}

.config-editor-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.config-validation-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.config-validation-item {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px;
  padding: 7px 8px;
  background: rgba(200, 48, 40, 0.08);
  border-left: 2px solid rgba(200, 48, 40, 0.35);
  font-size: 6px;
  line-height: 1.6;
}

.config-validation-path {
  color: var(--vermillion);
}

.config-validation-message {
  color: var(--ink);
  word-break: break-word;
}

@media (max-width: 700px) {
  .character-modal {
    width: calc(100vw - 12px);
    max-height: calc(100vh - 18px);
  }

  .modal-grid {
    grid-template-columns: 1fr;
  }

  .achievement-toolbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .achievement-search {
    width: 100%;
  }

  .achievement-search-input {
    min-width: 0;
    width: 100%;
  }

  .config-editor-meta {
    grid-template-columns: 1fr;
  }

  .config-editor-actions {
    flex-direction: column;
    align-items: stretch;
  }

  .dashboard-control-status-grid {
    grid-template-columns: 1fr;
  }
}

/* ============================================================
   FOOTER
   ============================================================ */
.page-footer {
  position: relative;
  z-index: 2;
  text-align: center;
  padding: 8px 16px 24px;
}

.page-footer p {
  font-size: 6px;
  color: var(--ink-faint);
  letter-spacing: 2px;
}

/* ============================================================
   RESPONSIVE
   ============================================================ */
@media (max-width: 920px) {
  .cards-container {
    flex-direction: column;
    align-items: center;
  }
}
</style>
</head>
<body>

<!-- Floating petals + ink drops container -->
<div class="petals-container" id="petalsContainer"></div>

<!-- Header -->
<header class="page-header">
  <h1>ARTIFACTS MMO</h1>
  <p class="subtitle">Bot Manager</p>
  <div class="divider">
    <span class="divider-line"></span>
    <span class="divider-diamond"></span>
    <span class="divider-line"></span>
  </div>
</header>

<div class="dashboard-controls">
  <button
    class="action-btn dashboard-control-btn"
    id="openConfigBtn"
    type="button"
    title="Config editor"
    aria-haspopup="dialog"
    hidden
  >CONFIG</button>
  <button
    class="action-btn dashboard-control-btn"
    id="restartBotBtn"
    type="button"
    title="Restart bot runtime"
    data-runtime-control="restart"
    hidden
  >RESTART BOT</button>
</div>
<section class="dashboard-control-status" id="controlStatusPanel" aria-live="polite" hidden>
  <div class="dashboard-control-status-grid">
    <article class="modal-stat">
      <div class="modal-stat-label">Runtime</div>
      <div class="modal-stat-value dashboard-control-status-value" id="controlRuntimeState">--</div>
    </article>
    <article class="modal-stat">
      <div class="modal-stat-label">Operation</div>
      <div class="modal-stat-value dashboard-control-status-value" id="controlOperationState">IDLE</div>
    </article>
    <article class="modal-stat">
      <div class="modal-stat-label">Updated</div>
      <div class="modal-stat-value dashboard-control-status-value" id="controlStatusUpdatedAt">--</div>
    </article>
  </div>
</section>
<div class="dashboard-control-banner" id="controlResultBanner" aria-live="polite" hidden></div>

<!-- Cards -->
<main class="cards-container" id="cardsContainer"></main>

<!-- Character modal host -->
<div class="modal-host" id="modalHost" hidden>
  <div class="modal-scrim" id="modalScrim"></div>
  <section
    class="character-modal"
    id="characterModal"
    role="dialog"
    aria-modal="true"
    aria-labelledby="modalTitle"
    tabindex="-1"
  >
    <header class="modal-header">
      <div>
        <p class="modal-kind" id="modalKind">DETAIL</p>
        <h2 class="modal-title" id="modalTitle">Character</h2>
      </div>
      <button type="button" class="modal-close" id="modalCloseBtn" aria-label="Close character detail modal">CLOSE</button>
    </header>
    <div class="modal-banner" id="modalBanner" hidden></div>
    <div class="modal-content" id="modalContent"></div>
  </section>
</div>

<!-- Footer -->
<footer class="page-footer">
  <div class="divider" style="margin-bottom: 12px;">
    <span class="divider-line"></span>
    <span class="divider-diamond"></span>
    <span class="divider-line"></span>
  </div>
  <p>SUMI-E INK WASH v1.0</p>
</footer>

<script>
const PLACEHOLDER_LOG = 'OFFLINE — waiting for runtime updates';

/* ==============================================================
   PORTRAIT PIXEL ART DEFINITIONS
   16x16 grid, drawn at native res then displayed at 96x96 via CSS
   ============================================================== */
const PORTRAITS = {
  warrior: {
    pixels: [
      { x: 5, y: 0, c: '#607890' }, { x: 6, y: 0, c: '#607890' }, { x: 7, y: 0, c: '#607890' }, { x: 8, y: 0, c: '#607890' }, { x: 9, y: 0, c: '#607890' },
      { x: 4, y: 1, c: '#607890' }, { x: 5, y: 1, c: '#789cb8' }, { x: 6, y: 1, c: '#789cb8' }, { x: 7, y: 1, c: '#90b8d0' }, { x: 8, y: 1, c: '#789cb8' }, { x: 9, y: 1, c: '#789cb8' }, { x: 10, y: 1, c: '#607890' },
      { x: 3, y: 2, c: '#607890' }, { x: 4, y: 2, c: '#789cb8' }, { x: 5, y: 2, c: '#90b8d0' }, { x: 6, y: 2, c: '#789cb8' }, { x: 7, y: 2, c: '#90b8d0' }, { x: 8, y: 2, c: '#789cb8' }, { x: 9, y: 2, c: '#90b8d0' }, { x: 10, y: 2, c: '#789cb8' }, { x: 11, y: 2, c: '#607890' },
      { x: 2, y: 3, c: '#506878' }, { x: 3, y: 3, c: '#607890' }, { x: 4, y: 3, c: '#607890' }, { x: 5, y: 3, c: '#607890' }, { x: 6, y: 3, c: '#607890' }, { x: 7, y: 3, c: '#607890' }, { x: 8, y: 3, c: '#607890' }, { x: 9, y: 3, c: '#607890' }, { x: 10, y: 3, c: '#607890' }, { x: 11, y: 3, c: '#607890' }, { x: 12, y: 3, c: '#506878' },
      { x: 4, y: 4, c: '#e8c8a0' }, { x: 5, y: 4, c: '#e8c8a0' }, { x: 6, y: 4, c: '#f0d8b8' }, { x: 7, y: 4, c: '#f0d8b8' }, { x: 8, y: 4, c: '#f0d8b8' }, { x: 9, y: 4, c: '#e8c8a0' }, { x: 10, y: 4, c: '#e8c8a0' },
      { x: 3, y: 5, c: '#e8c8a0' }, { x: 4, y: 5, c: '#f0d8b8' }, { x: 5, y: 5, c: '#382828' }, { x: 6, y: 5, c: '#f0d8b8' }, { x: 7, y: 5, c: '#f0d8b8' }, { x: 8, y: 5, c: '#f0d8b8' }, { x: 9, y: 5, c: '#382828' }, { x: 10, y: 5, c: '#f0d8b8' }, { x: 11, y: 5, c: '#e8c8a0' },
      { x: 3, y: 6, c: '#e8c8a0' }, { x: 4, y: 6, c: '#f0d8b8' }, { x: 5, y: 6, c: '#f0d8b8' }, { x: 6, y: 6, c: '#f0d8b8' }, { x: 7, y: 6, c: '#d8b090' }, { x: 8, y: 6, c: '#f0d8b8' }, { x: 9, y: 6, c: '#f0d8b8' }, { x: 10, y: 6, c: '#f0d8b8' }, { x: 11, y: 6, c: '#e8c8a0' },
      { x: 4, y: 7, c: '#e8c8a0' }, { x: 5, y: 7, c: '#f0d8b8' }, { x: 6, y: 7, c: '#c09880' }, { x: 7, y: 7, c: '#c09880' }, { x: 8, y: 7, c: '#c09880' }, { x: 9, y: 7, c: '#f0d8b8' }, { x: 10, y: 7, c: '#e8c8a0' },
      { x: 5, y: 8, c: '#e8c8a0' }, { x: 6, y: 8, c: '#e8c8a0' }, { x: 7, y: 8, c: '#e8c8a0' }, { x: 8, y: 8, c: '#e8c8a0' }, { x: 9, y: 8, c: '#e8c8a0' },
      { x: 6, y: 9, c: '#d8b890' }, { x: 7, y: 9, c: '#d8b890' }, { x: 8, y: 9, c: '#d8b890' },
      { x: 2, y: 10, c: '#607890' }, { x: 3, y: 10, c: '#789cb8' }, { x: 4, y: 10, c: '#789cb8' }, { x: 5, y: 10, c: '#607890' }, { x: 6, y: 10, c: '#607890' }, { x: 7, y: 10, c: '#607890' }, { x: 8, y: 10, c: '#607890' }, { x: 9, y: 10, c: '#607890' }, { x: 10, y: 10, c: '#789cb8' }, { x: 11, y: 10, c: '#789cb8' }, { x: 12, y: 10, c: '#607890' },
      { x: 1, y: 11, c: '#506878' }, { x: 2, y: 11, c: '#789cb8' }, { x: 3, y: 11, c: '#90b8d0' }, { x: 4, y: 11, c: '#789cb8' }, { x: 5, y: 11, c: '#607890' }, { x: 6, y: 11, c: '#789cb8' }, { x: 7, y: 11, c: '#90b8d0' }, { x: 8, y: 11, c: '#789cb8' }, { x: 9, y: 11, c: '#607890' }, { x: 10, y: 11, c: '#789cb8' }, { x: 11, y: 11, c: '#90b8d0' }, { x: 12, y: 11, c: '#789cb8' }, { x: 13, y: 11, c: '#506878' },
      { x: 1, y: 12, c: '#506878' }, { x: 2, y: 12, c: '#607890' }, { x: 3, y: 12, c: '#789cb8' }, { x: 4, y: 12, c: '#607890' }, { x: 5, y: 12, c: '#607890' }, { x: 6, y: 12, c: '#789cb8' }, { x: 7, y: 12, c: '#c0c0c0' }, { x: 8, y: 12, c: '#789cb8' }, { x: 9, y: 12, c: '#607890' }, { x: 10, y: 12, c: '#607890' }, { x: 11, y: 12, c: '#789cb8' }, { x: 12, y: 12, c: '#607890' }, { x: 13, y: 12, c: '#506878' },
      { x: 2, y: 13, c: '#607890' }, { x: 3, y: 13, c: '#607890' }, { x: 4, y: 13, c: '#607890' }, { x: 5, y: 13, c: '#607890' }, { x: 6, y: 13, c: '#607890' }, { x: 7, y: 13, c: '#607890' }, { x: 8, y: 13, c: '#607890' }, { x: 9, y: 13, c: '#607890' }, { x: 10, y: 13, c: '#607890' }, { x: 11, y: 13, c: '#607890' }, { x: 12, y: 13, c: '#607890' },
    ]
  },
  mage: {
    pixels: [
      { x: 7, y: 0, c: '#584078' },
      { x: 6, y: 1, c: '#584078' }, { x: 7, y: 1, c: '#7858a0' }, { x: 8, y: 1, c: '#584078' },
      { x: 5, y: 2, c: '#584078' }, { x: 6, y: 2, c: '#7858a0' }, { x: 7, y: 2, c: '#9070b8' }, { x: 8, y: 2, c: '#7858a0' }, { x: 9, y: 2, c: '#584078' },
      { x: 2, y: 3, c: '#483068' }, { x: 3, y: 3, c: '#584078' }, { x: 4, y: 3, c: '#584078' }, { x: 5, y: 3, c: '#7858a0' }, { x: 6, y: 3, c: '#7858a0' }, { x: 7, y: 3, c: '#f8e060' }, { x: 8, y: 3, c: '#7858a0' }, { x: 9, y: 3, c: '#7858a0' }, { x: 10, y: 3, c: '#584078' }, { x: 11, y: 3, c: '#584078' }, { x: 12, y: 3, c: '#483068' },
      { x: 3, y: 4, c: '#c0c0d0' }, { x: 4, y: 4, c: '#e8c8a0' }, { x: 5, y: 4, c: '#f0d8b8' }, { x: 6, y: 4, c: '#f0d8b8' }, { x: 7, y: 4, c: '#f0d8b8' }, { x: 8, y: 4, c: '#f0d8b8' }, { x: 9, y: 4, c: '#f0d8b8' }, { x: 10, y: 4, c: '#e8c8a0' }, { x: 11, y: 4, c: '#c0c0d0' },
      { x: 3, y: 5, c: '#c0c0d0' }, { x: 4, y: 5, c: '#f0d8b8' }, { x: 5, y: 5, c: '#382858' }, { x: 6, y: 5, c: '#f0d8b8' }, { x: 7, y: 5, c: '#f0d8b8' }, { x: 8, y: 5, c: '#f0d8b8' }, { x: 9, y: 5, c: '#382858' }, { x: 10, y: 5, c: '#f0d8b8' }, { x: 11, y: 5, c: '#c0c0d0' },
      { x: 3, y: 6, c: '#c0c0d0' }, { x: 4, y: 6, c: '#f0d8b8' }, { x: 5, y: 6, c: '#f0d8b8' }, { x: 6, y: 6, c: '#f0d8b8' }, { x: 7, y: 6, c: '#d8b090' }, { x: 8, y: 6, c: '#f0d8b8' }, { x: 9, y: 6, c: '#f0d8b8' }, { x: 10, y: 6, c: '#f0d8b8' }, { x: 11, y: 6, c: '#c0c0d0' },
      { x: 4, y: 7, c: '#e8c8a0' }, { x: 5, y: 7, c: '#f0d8b8' }, { x: 6, y: 7, c: '#b88880' }, { x: 7, y: 7, c: '#f0d8b8' }, { x: 8, y: 7, c: '#b88880' }, { x: 9, y: 7, c: '#f0d8b8' }, { x: 10, y: 7, c: '#e8c8a0' },
      { x: 5, y: 8, c: '#e8c8a0' }, { x: 6, y: 8, c: '#e8c8a0' }, { x: 7, y: 8, c: '#e8c8a0' }, { x: 8, y: 8, c: '#e8c8a0' }, { x: 9, y: 8, c: '#e8c8a0' },
      { x: 5, y: 9, c: '#c0c0d0' }, { x: 6, y: 9, c: '#d8b890' }, { x: 7, y: 9, c: '#d8b890' }, { x: 8, y: 9, c: '#d8b890' }, { x: 9, y: 9, c: '#c0c0d0' },
      { x: 3, y: 10, c: '#584078' }, { x: 4, y: 10, c: '#7858a0' }, { x: 5, y: 10, c: '#584078' }, { x: 6, y: 10, c: '#584078' }, { x: 7, y: 10, c: '#584078' }, { x: 8, y: 10, c: '#584078' }, { x: 9, y: 10, c: '#584078' }, { x: 10, y: 10, c: '#7858a0' }, { x: 11, y: 10, c: '#584078' },
      { x: 2, y: 11, c: '#483068' }, { x: 3, y: 11, c: '#7858a0' }, { x: 4, y: 11, c: '#9070b8' }, { x: 5, y: 11, c: '#7858a0' }, { x: 6, y: 11, c: '#584078' }, { x: 7, y: 11, c: '#f8e060' }, { x: 8, y: 11, c: '#584078' }, { x: 9, y: 11, c: '#7858a0' }, { x: 10, y: 11, c: '#9070b8' }, { x: 11, y: 11, c: '#7858a0' }, { x: 12, y: 11, c: '#483068' },
      { x: 2, y: 12, c: '#483068' }, { x: 3, y: 12, c: '#584078' }, { x: 4, y: 12, c: '#7858a0' }, { x: 5, y: 12, c: '#584078' }, { x: 6, y: 12, c: '#7858a0' }, { x: 7, y: 12, c: '#9070b8' }, { x: 8, y: 12, c: '#7858a0' }, { x: 9, y: 12, c: '#584078' }, { x: 10, y: 12, c: '#7858a0' }, { x: 11, y: 12, c: '#584078' }, { x: 12, y: 12, c: '#483068' },
      { x: 3, y: 13, c: '#584078' }, { x: 4, y: 13, c: '#584078' }, { x: 5, y: 13, c: '#584078' }, { x: 6, y: 13, c: '#584078' }, { x: 7, y: 13, c: '#584078' }, { x: 8, y: 13, c: '#584078' }, { x: 9, y: 13, c: '#584078' }, { x: 10, y: 13, c: '#584078' }, { x: 11, y: 13, c: '#584078' },
    ]
  },
  gatherer: {
    pixels: [
      { x: 5, y: 0, c: '#3a6838' }, { x: 6, y: 0, c: '#3a6838' }, { x: 7, y: 0, c: '#3a6838' }, { x: 8, y: 0, c: '#3a6838' }, { x: 9, y: 0, c: '#3a6838' },
      { x: 4, y: 1, c: '#3a6838' }, { x: 5, y: 1, c: '#508848' }, { x: 6, y: 1, c: '#508848' }, { x: 7, y: 1, c: '#60a058' }, { x: 8, y: 1, c: '#508848' }, { x: 9, y: 1, c: '#508848' }, { x: 10, y: 1, c: '#3a6838' },
      { x: 3, y: 2, c: '#3a6838' }, { x: 4, y: 2, c: '#508848' }, { x: 5, y: 2, c: '#60a058' }, { x: 6, y: 2, c: '#508848' }, { x: 7, y: 2, c: '#60a058' }, { x: 8, y: 2, c: '#508848' }, { x: 9, y: 2, c: '#60a058' }, { x: 10, y: 2, c: '#508848' }, { x: 11, y: 2, c: '#3a6838' },
      { x: 3, y: 3, c: '#2a5028' }, { x: 4, y: 3, c: '#3a6838' }, { x: 5, y: 3, c: '#3a6838' }, { x: 6, y: 3, c: '#3a6838' }, { x: 7, y: 3, c: '#3a6838' }, { x: 8, y: 3, c: '#3a6838' }, { x: 9, y: 3, c: '#3a6838' }, { x: 10, y: 3, c: '#3a6838' }, { x: 11, y: 3, c: '#2a5028' },
      { x: 3, y: 4, c: '#3a6838' }, { x: 4, y: 4, c: '#e0c098' }, { x: 5, y: 4, c: '#f0d8b8' }, { x: 6, y: 4, c: '#f0d8b8' }, { x: 7, y: 4, c: '#f0d8b8' }, { x: 8, y: 4, c: '#f0d8b8' }, { x: 9, y: 4, c: '#f0d8b8' }, { x: 10, y: 4, c: '#e0c098' }, { x: 11, y: 4, c: '#3a6838' },
      { x: 3, y: 5, c: '#3a6838' }, { x: 4, y: 5, c: '#f0d8b8' }, { x: 5, y: 5, c: '#283818' }, { x: 6, y: 5, c: '#f0d8b8' }, { x: 7, y: 5, c: '#f0d8b8' }, { x: 8, y: 5, c: '#f0d8b8' }, { x: 9, y: 5, c: '#283818' }, { x: 10, y: 5, c: '#f0d8b8' }, { x: 11, y: 5, c: '#3a6838' },
      { x: 4, y: 6, c: '#f0d8b8' }, { x: 5, y: 6, c: '#f0d8b8' }, { x: 6, y: 6, c: '#f0d8b8' }, { x: 7, y: 6, c: '#d8b090' }, { x: 8, y: 6, c: '#f0d8b8' }, { x: 9, y: 6, c: '#f0d8b8' }, { x: 10, y: 6, c: '#f0d8b8' },
      { x: 4, y: 7, c: '#e8c8a0' }, { x: 5, y: 7, c: '#f0d8b8' }, { x: 6, y: 7, c: '#c09880' }, { x: 7, y: 7, c: '#c09880' }, { x: 8, y: 7, c: '#c09880' }, { x: 9, y: 7, c: '#f0d8b8' }, { x: 10, y: 7, c: '#e8c8a0' },
      { x: 5, y: 8, c: '#e8c8a0' }, { x: 6, y: 8, c: '#e8c8a0' }, { x: 7, y: 8, c: '#e8c8a0' }, { x: 8, y: 8, c: '#e8c8a0' }, { x: 9, y: 8, c: '#e8c8a0' },
      { x: 5, y: 9, c: '#a07848' }, { x: 6, y: 9, c: '#d8b890' }, { x: 7, y: 9, c: '#d8b890' }, { x: 8, y: 9, c: '#d8b890' }, { x: 9, y: 9, c: '#a07848' },
      { x: 3, y: 10, c: '#3a6838' }, { x: 4, y: 10, c: '#508848' }, { x: 5, y: 10, c: '#3a6838' }, { x: 6, y: 10, c: '#3a6838' }, { x: 7, y: 10, c: '#3a6838' }, { x: 8, y: 10, c: '#3a6838' }, { x: 9, y: 10, c: '#3a6838' }, { x: 10, y: 10, c: '#508848' }, { x: 11, y: 10, c: '#3a6838' },
      { x: 2, y: 11, c: '#2a5028' }, { x: 3, y: 11, c: '#508848' }, { x: 4, y: 11, c: '#60a058' }, { x: 5, y: 11, c: '#508848' }, { x: 6, y: 11, c: '#3a6838' }, { x: 7, y: 11, c: '#a07848' }, { x: 8, y: 11, c: '#3a6838' }, { x: 9, y: 11, c: '#508848' }, { x: 10, y: 11, c: '#60a058' }, { x: 11, y: 11, c: '#508848' }, { x: 12, y: 11, c: '#2a5028' },
      { x: 2, y: 12, c: '#2a5028' }, { x: 3, y: 12, c: '#3a6838' }, { x: 4, y: 12, c: '#508848' }, { x: 5, y: 12, c: '#3a6838' }, { x: 6, y: 12, c: '#508848' }, { x: 7, y: 12, c: '#60a058' }, { x: 8, y: 12, c: '#508848' }, { x: 9, y: 12, c: '#3a6838' }, { x: 10, y: 12, c: '#508848' }, { x: 11, y: 12, c: '#3a6838' }, { x: 12, y: 12, c: '#2a5028' },
      { x: 3, y: 13, c: '#3a6838' }, { x: 4, y: 13, c: '#3a6838' }, { x: 5, y: 13, c: '#3a6838' }, { x: 6, y: 13, c: '#3a6838' }, { x: 7, y: 13, c: '#3a6838' }, { x: 8, y: 13, c: '#3a6838' }, { x: 9, y: 13, c: '#3a6838' }, { x: 10, y: 13, c: '#3a6838' }, { x: 11, y: 13, c: '#3a6838' },
    ]
  }
};

/* ==============================================================
   DRAW PORTRAIT ON CANVAS — paper-colored background
   ============================================================== */
function drawPortrait(canvas, type) {
  const size = 14;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  // Warm washi paper background
  ctx.fillStyle = '#ede4d4';
  ctx.fillRect(0, 0, size, size);

  const data = PORTRAITS[type];
  if (!data) return;
  data.pixels.forEach(p => {
    ctx.fillStyle = p.c;
    ctx.fillRect(p.x, p.y, 1, 1);
  });
}

/* ==============================================================
   DRAW CHERRY BRANCH ON CANVAS — sumi-e brushy style
   Variable stroke width to simulate brush pressure
   ============================================================== */
function drawCherryBranch(canvas) {
  const w = 280;
  const h = 40;
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');

  ctx.clearRect(0, 0, w, h);

  // Branch path — a gentle curve from left to right
  const branchPoints = [
    [0, 24], [20, 22], [40, 18], [60, 16], [80, 15], [100, 16],
    [120, 18], [140, 17], [160, 14], [180, 12], [200, 13],
    [220, 15], [240, 18], [260, 20], [280, 22]
  ];

  // Brush pressure map — width varies along the branch (1-3px)
  // Thicker at start (brush loaded with ink), thins out, thickens again
  const pressureMap = [3, 3, 2, 2, 3, 2, 2, 1, 2, 3, 2, 2, 1, 1, 1];

  // Draw branch with variable width — sumi-e brush simulation
  for (let i = 0; i < branchPoints.length - 1; i++) {
    const [x1, y1] = branchPoints[i];
    const [x2, y2] = branchPoints[i + 1];
    const thickness = pressureMap[i] || 2;
    const steps = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));

    for (let s = 0; s <= steps; s++) {
      const t = steps === 0 ? 0 : s / steps;
      const x = Math.round(x1 + (x2 - x1) * t);
      const y = Math.round(y1 + (y2 - y1) * t);

      // Vary ink darkness along stroke — like real ink wash
      const inkDark = Math.random() > 0.7 ? '#382c28' : '#483830';
      ctx.fillStyle = inkDark;
      ctx.fillRect(x, y, thickness, thickness);

      // Add slight ink bleed on thicker strokes
      if (thickness >= 3 && Math.random() > 0.8) {
        ctx.fillStyle = 'rgba(56, 44, 40, 0.3)';
        ctx.fillRect(x - 1, y + thickness, 1, 1);
      }
    }
  }

  // Sub-branches — thinner, like light brush strokes
  const subBranches = [
    [[60, 16], [50, 8], [45, 4]],
    [[120, 18], [130, 10], [135, 6]],
    [[180, 12], [170, 6], [165, 2]],
    [[220, 15], [230, 8], [235, 5]],
    [[100, 16], [95, 10]],
    [[160, 14], [155, 8]],
  ];

  subBranches.forEach(branch => {
    for (let i = 0; i < branch.length - 1; i++) {
      const [x1, y1] = branch[i];
      const [x2, y2] = branch[i + 1];
      const steps = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
      for (let s = 0; s <= steps; s++) {
        const t = steps === 0 ? 0 : s / steps;
        const x = Math.round(x1 + (x2 - x1) * t);
        const y = Math.round(y1 + (y2 - y1) * t);
        // Thin sub-branches fade to lighter ink
        const alpha = 1.0 - (t * 0.4);
        ctx.fillStyle = `rgba(72, 56, 48, ${alpha})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  });

  // Blossoms — mix of pink AND ink-wash gray blossoms
  const blossomPositions = [
    [45, 3], [48, 5], [42, 6],
    [130, 6], [133, 8], [127, 9], [135, 4],
    [165, 1], [168, 3], [162, 4], [170, 5],
    [230, 4], [233, 6], [227, 7], [235, 3],
    [95, 8], [92, 10], [98, 9],
    [155, 6], [152, 8], [158, 7],
  ];

  const pinkColors = ['#d88898', '#e8a8b0', '#c87888', '#d89098', '#e0b0b8'];
  const grayColors = ['#a09890', '#b8b0a8', '#908880', '#988e84', '#a8a098'];

  blossomPositions.forEach(([bx, by], idx) => {
    // Every 3rd blossom is ink-wash gray
    const isGray = idx % 3 === 2;
    const colors = isGray ? grayColors : pinkColors;

    const offsets = [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]];
    offsets.forEach(([dx, dy], i) => {
      ctx.fillStyle = colors[i % colors.length];
      ctx.fillRect(bx + dx * 2, by + dy * 2, 2, 2);
    });
    // Center dot — golden for pink, dark for gray
    ctx.fillStyle = isGray ? '#685848' : '#c8a850';
    ctx.fillRect(bx, by, 1, 1);
  });

  // Ink splatter marks near branch — decorative
  const splatters = [
    [30, 28], [75, 20], [145, 22], [210, 18], [250, 25]
  ];
  splatters.forEach(([sx, sy]) => {
    ctx.fillStyle = 'rgba(42, 36, 32, 0.12)';
    ctx.fillRect(sx, sy, 1, 1);
    if (Math.random() > 0.5) {
      ctx.fillRect(sx + 2, sy + 1, 1, 1);
    }
    if (Math.random() > 0.5) {
      ctx.fillRect(sx - 1, sy + 2, 1, 1);
    }
  });
}

/* ==============================================================
   BUILD CARD HTML
   ============================================================== */
const appState = {
  order: [],
  characters: new Map(),
};

const cardRefs = new Map();
let eventSource = null;
const CONFIG_MODAL_NAME = '__config__';
const MODAL_KIND_LABELS = {
  skills: 'Skills',
  inven: 'Inventory',
  equip: 'Equipment',
  stats: 'Stats',
  achiev: 'Achievements',
  config: 'Config',
};
const ACHIEVEMENT_FILTER_LABELS = {
  all: 'All',
  completed: 'Completed',
  'in-progress': 'In Progress',
};
const CONTROL_ACTION_LABELS = {
  reload: 'Reload Config',
  restart: 'Restart Bot',
};
const CONTROL_ACTION_ENDPOINTS = {
  reload: '/api/control/reload-config',
  restart: '/api/control/restart',
};
const CONTROL_OPERATION_STATE_VALUES = new Set(['idle', 'in-flight', 'success', 'failure']);
const CONTROL_STATUS_POLL_MS = 5000;
const runtimeFeatures = {
  configEditorAvailable: false,
  controlPanelAvailable: false,
};

const modalState = {
  activeCharacterName: '',
  activeKind: '',
  status: 'idle', // idle | loading | ready | error
  detail: null,
  errorText: '',
  activeSnapshotUpdatedAtMs: 0,
  fetchController: null,
  fetchSeq: 0,
  lastFocusedElement: null,
  achievementFilter: 'all',
  achievementSearch: '',
  configEditorText: '',
  configIfMatchHash: '',
  configValidationErrors: [],
  configBusy: false,
  configResultBanner: null,
  configActionController: null,
};

const modalRefs = {
  host: null,
  scrim: null,
  dialog: null,
  kind: null,
  title: null,
  banner: null,
  content: null,
  closeBtn: null,
  configBtn: null,
};

const controlState = {
  operationState: 'idle', // idle | in-flight | success | failure
  activeAction: '',
  statusSnapshot: null,
  statusError: '',
  resultBanner: null,
  actionController: null,
  statusController: null,
  statusSeq: 0,
  pollTimer: null,
  resetTimer: null,
};

const controlRefs = {
  restartBtn: null,
  statusPanel: null,
  runtimeState: null,
  operationState: null,
  updatedAt: null,
  banner: null,
};

function toNumber(value, fallback = 0) {
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function safeText(text, fallback = '') {
  const str = `${text ?? ''}`.trim();
  return str.length > 0 ? str : fallback;
}

function hashPortraitType(name) {
  let hash = 0;
  const value = `${name || ''}`;
  for (let i = 0; i < value.length; i++) {
    hash = ((hash << 5) - hash + value.charCodeAt(i)) | 0;
  }
  const idx = Math.abs(hash) % 3;
  if (idx === 0) return 'warrior';
  if (idx === 1) return 'mage';
  return 'gatherer';
}

function normalizeCharacter(raw) {
  const name = safeText(raw?.name, 'Unknown');
  const status = safeText(raw?.status, 'starting');
  const stale = !!raw?.stale;
  const offline = stale || status !== 'running';

  const maxHp = Math.max(0, toNumber(raw?.maxHp, 0));
  const hp = Math.max(0, toNumber(raw?.hp, 0));
  const maxXp = Math.max(0, toNumber(raw?.maxXp, 0));
  const xp = Math.max(0, toNumber(raw?.xp, 0));

  const taskLabel = safeText(raw?.task?.label, offline ? 'OFFLINE' : 'No active task');
  const logLatest = safeText(raw?.logLatest, offline ? PLACEHOLDER_LOG : 'No activity yet');

  const cooldown = raw?.cooldown || {};
  const totalSeconds = Math.max(0, toNumber(cooldown.totalSeconds, 0));
  const endsAtMs = Math.max(0, toNumber(cooldown.endsAtMs, 0));

  return {
    name,
    portraitType: safeText(raw?.portraitType, hashPortraitType(name)),
    status,
    stale,
    offline,
    lastUpdatedAtMs: Math.max(0, toNumber(raw?.lastUpdatedAtMs, 0)),
    level: Math.max(0, toNumber(raw?.level, 0)),
    hp,
    maxHp,
    xp,
    maxXp,
    taskLabel,
    logLatest,
    cooldown: {
      action: safeText(cooldown.action, ''),
      totalSeconds,
      endsAtMs,
    },
  };
}

function statPct(value, maxValue) {
  if (maxValue <= 0) return 0;
  return Math.max(0, Math.min(100, (value / maxValue) * 100));
}

function toKey(name) {
  return encodeURIComponent(name);
}

function buildCard(char, index) {
  const key = toKey(char.name);
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.charName = char.name;
  card.dataset.charKey = key;

  card.innerHTML = `
    <div class="cherry-branch">
      <canvas class="branch-canvas" data-branch="${key}" data-idx="${index}"></canvas>
    </div>
    <div class="card-inner">
      <div class="char-name" data-name="${key}">${char.name}</div>

      <div class="portrait-frame">
        <div class="portrait-border">
          <canvas class="portrait-canvas" data-portrait="${key}"></canvas>
        </div>
      </div>

      <div class="level-row">
        <span class="level-badge" data-level="${key}">LV 0</span>
      </div>

      <div class="stat-bars">
        <div class="stat-row">
          <span class="stat-label">HP</span>
          <div class="stat-bar-track">
            <div class="stat-bar-fill" data-hp-fill="${key}" style="width: 0%"></div>
          </div>
          <span class="stat-value" data-hp-text="${key}">0 / 0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">XP</span>
          <div class="stat-bar-track xp-track">
            <div class="stat-bar-fill xp-fill" data-xp-fill="${key}" style="width: 0%"></div>
          </div>
          <span class="stat-value" data-xp-text="${key}">0 / 0</span>
        </div>
      </div>

      <div class="cooldown-section">
        <div class="cooldown-label">COOLDOWN</div>
        <div class="cooldown-bar-track">
          <div class="cooldown-bar-fill" data-cd-bar="${key}" style="width: 0%"></div>
        </div>
        <div class="cooldown-text" data-cd-text="${key}">--</div>
      </div>

      <div class="info-panel">
        <div class="info-panel-label">LOG</div>
        <div class="info-panel-text" data-log="${key}">${PLACEHOLDER_LOG}</div>
      </div>

      <div class="info-panel">
        <div class="info-panel-label">TASK</div>
        <div class="info-panel-text" data-task="${key}">OFFLINE</div>
      </div>

      <div class="buttons-section">
        <div class="btn-row">
          <button class="action-btn" type="button" data-modal-kind="equip" title="Equipment" aria-haspopup="dialog">EQUIP</button>
          <button class="action-btn" type="button" data-modal-kind="inven" title="Inventory" aria-haspopup="dialog">INVEN</button>
        </div>
        <div class="btn-row">
          <button class="action-btn" type="button" data-modal-kind="skills" title="Skills" aria-haspopup="dialog">SKILLS</button>
        </div>
        <div class="btn-row">
          <button class="action-btn" type="button" data-modal-kind="stats" title="Stats" aria-haspopup="dialog">STATS</button>
          <button class="action-btn" type="button" data-modal-kind="achiev" title="Achievements" aria-haspopup="dialog">ACHIEV</button>
        </div>
      </div>
    </div>
  `;

  const refs = {
    root: card,
    key,
    portraitType: null,
    nameEl: card.querySelector(`[data-name="${key}"]`),
    portraitCanvas: card.querySelector(`[data-portrait="${key}"]`),
    levelEl: card.querySelector(`[data-level="${key}"]`),
    hpFill: card.querySelector(`[data-hp-fill="${key}"]`),
    hpText: card.querySelector(`[data-hp-text="${key}"]`),
    xpFill: card.querySelector(`[data-xp-fill="${key}"]`),
    xpText: card.querySelector(`[data-xp-text="${key}"]`),
    cdBar: card.querySelector(`[data-cd-bar="${key}"]`),
    cdText: card.querySelector(`[data-cd-text="${key}"]`),
    logText: card.querySelector(`[data-log="${key}"]`),
    taskText: card.querySelector(`[data-task="${key}"]`),
  };

  const branchCanvas = card.querySelector(`[data-branch="${key}"]`);
  if (branchCanvas) drawCherryBranch(branchCanvas);

  cardRefs.set(char.name, refs);
  return card;
}

function updateCooldown(refs, char) {
  if (!refs || !refs.cdBar || !refs.cdText) return;
  if (char.offline) {
    refs.cdBar.style.width = '0%';
    refs.cdBar.classList.remove('ready');
    refs.cdText.classList.remove('ready-flash');
    refs.cdText.textContent = '--';
    return;
  }

  const total = char.cooldown.totalSeconds;
  const endsAtMs = char.cooldown.endsAtMs;

  if (total <= 0 || endsAtMs <= 0) {
    refs.cdBar.style.width = '100%';
    refs.cdBar.classList.add('ready');
    refs.cdText.classList.add('ready-flash');
    refs.cdText.textContent = 'READY';
    return;
  }

  const remaining = Math.max(0, (endsAtMs - Date.now()) / 1000);
  if (remaining <= 0) {
    refs.cdBar.style.width = '100%';
    refs.cdBar.classList.add('ready');
    refs.cdText.classList.add('ready-flash');
    refs.cdText.textContent = 'READY';
    return;
  }

  const pct = Math.max(0, Math.min(100, (remaining / total) * 100));
  refs.cdBar.style.width = `${pct.toFixed(1)}%`;
  refs.cdBar.classList.remove('ready');
  refs.cdText.classList.remove('ready-flash');
  refs.cdText.textContent = `${remaining.toFixed(1)}s`;
}

function applyCharacterState(char) {
  const refs = cardRefs.get(char.name);
  if (!refs) return;

  refs.root.classList.toggle('offline', char.offline);
  refs.nameEl.textContent = char.name;
  refs.levelEl.textContent = `LV ${char.level}`;

  refs.hpFill.style.width = `${statPct(char.hp, char.maxHp).toFixed(1)}%`;
  refs.hpText.textContent = `${char.hp} / ${char.maxHp}`;

  refs.xpFill.style.width = `${statPct(char.xp, char.maxXp).toFixed(1)}%`;
  refs.xpText.textContent = `${char.xp} / ${char.maxXp}`;

  refs.logText.textContent = char.logLatest;
  refs.taskText.textContent = char.taskLabel;

  if (refs.portraitType !== char.portraitType) {
    refs.portraitType = char.portraitType;
    drawPortrait(refs.portraitCanvas, char.portraitType);
  }

  updateCooldown(refs, char);
}

function escapeHtml(value) {
  return `${value ?? ''}`
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function formatNumberish(value, fallback = '--') {
  const num = Number(value);
  return Number.isFinite(num) ? num.toLocaleString() : fallback;
}

function formatTime(value) {
  const ms = toNumber(value, 0);
  if (ms <= 0) return '--';
  const date = new Date(ms);
  return Number.isNaN(date.getTime())
    ? '--'
    : date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

function formatUpperToken(value, fallback = '--') {
  const text = safeText(value, '');
  if (!text) return fallback;
  return text.replace(/[_-]+/g, ' ').toUpperCase();
}

function normalizeControlAction(value, fallback = '') {
  const normalized = safeText(value, '').toLowerCase();
  if (normalized === 'reload' || normalized === 'reload-config' || normalized === 'reload_config') {
    return 'reload';
  }
  if (normalized === 'restart' || normalized === 'restart-bot' || normalized === 'restart_bot') {
    return 'restart';
  }
  return fallback;
}

function getControlActionLabel(action, fallback = '') {
  const normalized = normalizeControlAction(action, '');
  return CONTROL_ACTION_LABELS[normalized] || fallback;
}

function normalizeControlOperationState(value, fallback = 'idle') {
  const normalized = safeText(value, '').toLowerCase();
  if (
    normalized === 'pending'
    || normalized === 'inflight'
    || normalized === 'in_flight'
    || normalized === 'running'
    || normalized === 'busy'
  ) {
    return 'in-flight';
  }
  if (normalized === 'ok' || normalized === 'done' || normalized === 'completed') {
    return 'success';
  }
  if (normalized === 'failed' || normalized === 'fail' || normalized === 'error') {
    return 'failure';
  }
  if (CONTROL_OPERATION_STATE_VALUES.has(normalized)) {
    return normalized;
  }
  return CONTROL_OPERATION_STATE_VALUES.has(fallback) ? fallback : 'idle';
}

function setControlResultBanner(tone, text) {
  const normalizedTone = safeText(tone, '').toLowerCase();
  const normalizedText = safeText(text, '');
  if (!normalizedText) {
    controlState.resultBanner = null;
    return;
  }
  controlState.resultBanner = {
    tone: normalizedTone === 'info'
      || normalizedTone === 'success'
      || normalizedTone === 'warning'
      || normalizedTone === 'error'
      ? normalizedTone
      : 'warning',
    text: normalizedText,
  };
}

function clearControlResetTimer() {
  if (!controlState.resetTimer) return;
  clearTimeout(controlState.resetTimer);
  controlState.resetTimer = null;
}

function setControlOperationState(nextState, { action = '' } = {}) {
  const normalizedState = normalizeControlOperationState(nextState, 'idle');
  const nextAction = normalizeControlAction(action, controlState.activeAction);

  controlState.operationState = normalizedState;
  if (normalizedState === 'idle') {
    controlState.activeAction = '';
    clearControlResetTimer();
    return;
  }

  if (nextAction) {
    controlState.activeAction = nextAction;
  }

  clearControlResetTimer();
  if (normalizedState === 'success' || normalizedState === 'failure') {
    const stateAtSchedule = normalizedState;
    controlState.resetTimer = setTimeout(() => {
      if (controlState.operationState !== stateAtSchedule) return;
      controlState.operationState = 'idle';
      controlState.activeAction = '';
      setControlResultBanner('', '');
      renderControlPanel();
    }, 6000);
  }
}

function normalizeControlStatusSnapshot(rawPayload) {
  const sourceRaw = extractApiData(rawPayload);
  const source = sourceRaw && typeof sourceRaw === 'object' ? sourceRaw : {};
  const operation = source.operation && typeof source.operation === 'object' ? source.operation : {};
  const sourceErrorText = typeof source.error === 'string' ? source.error : '';

  const lifecycle = safeText(
    source.lifecycle
      ?? source.lifecycleState
      ?? source.runtimeState
      ?? source.state
      ?? source.status,
    'unknown'
  ).toLowerCase();

  const operationAction = normalizeControlAction(
    operation.name ?? operation.type ?? source.currentOperation ?? source.operationName ?? source.operation,
    ''
  );

  const operationState = safeText(
    operation.state ?? source.operationState ?? source.lockState ?? source.lockStatus,
    ''
  ).toLowerCase();

  const inFlight = toBoolLike(
    operation.inFlight ?? source.inFlight ?? source.operationInFlight ?? source.locked ?? source.busy
  )
    || operationState === 'in-flight'
    || operationState === 'pending'
    || operationState === 'running'
    || operationState === 'busy';

  const updatedAtMs = Math.max(0, toNumber(
    source.updatedAtMs
      ?? source.lastUpdatedAtMs
      ?? source.fetchedAtMs
      ?? source.updatedAt
      ?? source.timestamp
      ?? source.serverTimeMs,
    0
  ));

  const detail = safeText(
    operation.detail
      ?? source.detail
      ?? source.message
      ?? source.summary
      ?? source.error?.detail
      ?? source.error?.message
      ?? source.lastError?.detail
      ?? source.lastError?.message
      ?? sourceErrorText,
    ''
  );

  return {
    lifecycle: lifecycle || 'unknown',
    inFlight,
    operationAction,
    updatedAtMs: updatedAtMs || Date.now(),
    detail,
  };
}

function getControlOperationDisplayValue() {
  const actionLabel = formatUpperToken(getControlActionLabel(controlState.activeAction, ''), '');
  if (controlState.operationState === 'in-flight') {
    return actionLabel ? `IN-FLIGHT - ${actionLabel}` : 'IN-FLIGHT';
  }
  if ((controlState.operationState === 'success' || controlState.operationState === 'failure') && actionLabel) {
    return `${formatUpperToken(controlState.operationState, 'IDLE')} - ${actionLabel}`;
  }
  if (controlState.operationState === 'idle' && controlState.statusSnapshot?.inFlight) {
    const statusAction = formatUpperToken(getControlActionLabel(controlState.statusSnapshot.operationAction, ''), '');
    return statusAction ? `IN-FLIGHT - ${statusAction}` : 'IN-FLIGHT';
  }
  return formatUpperToken(controlState.operationState, 'IDLE');
}

function renderControlPanel() {
  const controlsAvailable = runtimeFeatures.controlPanelAvailable;

  if (controlRefs.restartBtn) {
    controlRefs.restartBtn.hidden = !controlsAvailable;
  }
  if (controlRefs.statusPanel) {
    controlRefs.statusPanel.hidden = !controlsAvailable;
  }

  if (!controlsAvailable) {
    if (controlRefs.restartBtn) controlRefs.restartBtn.disabled = true;
    if (controlRefs.runtimeState) {
      controlRefs.runtimeState.textContent = '--';
      controlRefs.runtimeState.classList.remove('is-error');
    }
    if (controlRefs.operationState) {
      controlRefs.operationState.textContent = 'IDLE';
      controlRefs.operationState.classList.remove('is-error');
    }
    if (controlRefs.updatedAt) {
      controlRefs.updatedAt.textContent = '--';
      controlRefs.updatedAt.classList.remove('is-error');
    }
    if (controlRefs.banner) {
      controlRefs.banner.hidden = true;
      controlRefs.banner.className = 'dashboard-control-banner';
      controlRefs.banner.textContent = '';
    }
    return;
  }

  const snapshot = controlState.statusSnapshot;
  const serverLocked = !!snapshot?.inFlight;
  const localLocked = controlState.operationState === 'in-flight';
  const controlsLocked = serverLocked || localLocked;

  if (controlRefs.restartBtn) {
    controlRefs.restartBtn.disabled = controlsLocked;
  }

  const runtimeValue = formatUpperToken(snapshot?.lifecycle, 'UNKNOWN');
  if (controlRefs.runtimeState) {
    controlRefs.runtimeState.textContent = runtimeValue;
    controlRefs.runtimeState.classList.toggle('is-error', runtimeValue === 'ERROR' || !!controlState.statusError);
  }

  if (controlRefs.operationState) {
    controlRefs.operationState.textContent = getControlOperationDisplayValue();
    controlRefs.operationState.classList.toggle('is-error', controlState.operationState === 'failure');
  }

  if (controlRefs.updatedAt) {
    controlRefs.updatedAt.textContent = formatTime(snapshot?.updatedAtMs);
    controlRefs.updatedAt.classList.toggle('is-error', !!controlState.statusError);
  }

  if (controlRefs.banner) {
    const banner = controlState.resultBanner;
    if (!banner) {
      controlRefs.banner.hidden = true;
      controlRefs.banner.className = 'dashboard-control-banner';
      controlRefs.banner.textContent = '';
    } else {
      controlRefs.banner.hidden = false;
      controlRefs.banner.className = `dashboard-control-banner ${banner.tone}`;
      controlRefs.banner.textContent = banner.text;
    }
  }
}

function stopControlStatusPolling() {
  if (controlState.pollTimer) {
    clearInterval(controlState.pollTimer);
    controlState.pollTimer = null;
  }
  if (controlState.statusController) {
    controlState.statusController.abort();
    controlState.statusController = null;
  }
}

function startControlStatusPolling() {
  stopControlStatusPolling();
  if (!runtimeFeatures.controlPanelAvailable) return;
  controlState.pollTimer = setInterval(() => {
    fetchControlStatus({ silentErrors: true });
  }, CONTROL_STATUS_POLL_MS);
}

function hasMeaningfulStatValue(value) {
  const text = safeText(value, '');
  if (!text) return false;
  if (text === '--') return false;
  if (text === '-- / --') return false;
  if (text.startsWith('--, --')) return false;
  return true;
}

function normalizeSkills(rawSkills) {
  const rows = [];
  if (Array.isArray(rawSkills)) {
    rawSkills.forEach((item, idx) => {
      const code = safeText(item?.code, `skill-${idx + 1}`);
      rows.push({
        code,
        level: Math.max(0, toNumber(item?.level, 0)),
        xp: Math.max(0, toNumber(item?.xp, 0)),
        maxXp: Math.max(0, toNumber(item?.maxXp, 0)),
        pct: Math.max(0, Math.min(100, toNumber(item?.pct, statPct(toNumber(item?.xp, 0), toNumber(item?.maxXp, 0))))),
      });
    });
  } else if (rawSkills && typeof rawSkills === 'object') {
    Object.entries(rawSkills).forEach(([code, value]) => {
      const item = value && typeof value === 'object' ? value : { level: value };
      rows.push({
        code: safeText(item?.code, code),
        level: Math.max(0, toNumber(item?.level, 0)),
        xp: Math.max(0, toNumber(item?.xp, 0)),
        maxXp: Math.max(0, toNumber(item?.maxXp, 0)),
        pct: Math.max(0, Math.min(100, toNumber(item?.pct, statPct(toNumber(item?.xp, 0), toNumber(item?.maxXp, 0))))),
      });
    });
  }

  return rows
    .filter((item) => !!item.code)
    .sort((a, b) => b.level - a.level || b.xp - a.xp || a.code.localeCompare(b.code));
}

function normalizeInventory(rawInventory) {
  const rows = [];
  if (Array.isArray(rawInventory)) {
    rawInventory.forEach((item, idx) => {
      rows.push({
        code: safeText(item?.code, ''),
        quantity: Math.max(0, toNumber(item?.quantity, 0)),
        slotIndex: Number.isFinite(Number(item?.slotIndex)) ? Number(item.slotIndex) : idx,
      });
    });
  } else if (rawInventory && typeof rawInventory === 'object') {
    Object.entries(rawInventory).forEach(([key, value], idx) => {
      const item = value && typeof value === 'object' ? value : { code: key, quantity: value };
      rows.push({
        code: safeText(item?.code, Number.isFinite(Number(key)) ? '' : key),
        quantity: Math.max(0, toNumber(item?.quantity, 0)),
        slotIndex: Number.isFinite(Number(item?.slotIndex))
          ? Number(item.slotIndex)
          : (Number.isFinite(Number(key)) ? Number(key) : idx),
      });
    });
  }

  return rows
    .filter((item) => item.code && item.quantity > 0)
    .sort((a, b) => a.slotIndex - b.slotIndex || a.code.localeCompare(b.code));
}

function normalizeEquipment(rawEquipment) {
  const rows = [];
  if (Array.isArray(rawEquipment)) {
    rawEquipment.forEach((item, idx) => {
      rows.push({
        slot: safeText(item?.slot, `slot-${idx + 1}`),
        code: safeText(item?.code, 'empty'),
        quantity: Math.max(0, toNumber(item?.quantity, item?.code ? 1 : 0)),
      });
    });
  } else if (rawEquipment && typeof rawEquipment === 'object') {
    Object.entries(rawEquipment).forEach(([slot, value]) => {
      if (!value) {
        rows.push({ slot: safeText(slot, 'slot'), code: 'empty', quantity: 0 });
        return;
      }
      const item = value && typeof value === 'object' ? value : { code: value, quantity: 1 };
      rows.push({
        slot: safeText(item?.slot, slot),
        code: safeText(item?.code, 'empty'),
        quantity: Math.max(0, toNumber(item?.quantity, item?.code ? 1 : 0)),
      });
    });
  }

  return rows.sort((a, b) => a.slot.localeCompare(b.slot));
}

function normalizeLogHistory(rawHistory) {
  if (!Array.isArray(rawHistory)) return [];
  return rawHistory
    .map((item) => {
      if (typeof item === 'string') {
        return { atMs: 0, level: 'info', line: item };
      }
      return {
        atMs: Math.max(0, toNumber(item?.atMs ?? item?.at ?? item?.ts, 0)),
        level: safeText(item?.level, 'info'),
        line: safeText(item?.line ?? item?.message, ''),
      };
    })
    .filter((entry) => !!entry.line)
    .sort((a, b) => b.atMs - a.atMs);
}

function closestFromEventTarget(event, selector) {
  const rawTarget = event?.target;
  if (rawTarget instanceof Element) {
    return rawTarget.closest(selector);
  }
  const parent = rawTarget?.parentElement;
  if (parent instanceof Element) {
    return parent.closest(selector);
  }
  return null;
}

function extractApiData(payload) {
  if (payload && typeof payload === 'object' && 'data' in payload) {
    return payload.data;
  }
  return payload;
}

function setConfigResultBanner(tone, text) {
  const normalizedTone = safeText(tone, '').toLowerCase();
  const normalizedText = safeText(text, '');
  if (!normalizedText) {
    modalState.configResultBanner = null;
    return;
  }
  modalState.configResultBanner = {
    tone: normalizedTone === 'success' || normalizedTone === 'warning' || normalizedTone === 'error'
      ? normalizedTone
      : 'warning',
    text: normalizedText,
  };
}

function normalizeValidationPath(pathValue) {
  if (Array.isArray(pathValue)) {
    if (pathValue.length === 0) return '$';
    return pathValue.reduce((acc, part) => {
      if (typeof part === 'number') return `${acc}[${part}]`;
      const token = safeText(part, '');
      return token ? `${acc}.${token}` : acc;
    }, '$');
  }

  const text = safeText(pathValue, '');
  if (!text) return '$';
  if (text.startsWith('$')) return text;
  if (text.startsWith('/')) {
    const tokens = text
      .split('/')
      .filter(Boolean)
      .map((token) => token.replace(/~1/g, '/').replace(/~0/g, '~'));
    if (tokens.length === 0) return '$';
    return `$${tokens.map((token) => (/^\d+$/.test(token) ? `[${token}]` : `.${token}`)).join('')}`;
  }
  if (/^\d+$/.test(text)) return `$[${text}]`;
  if (text.startsWith('.')) return `$${text}`;
  return `$.${text}`;
}

function normalizeValidationErrors(rawPayload) {
  const source = extractApiData(rawPayload);
  let rows = [];

  if (Array.isArray(source)) {
    rows = source;
  } else if (source && typeof source === 'object') {
    if (Array.isArray(source.errors)) rows = source.errors;
    else if (Array.isArray(source.validationErrors)) rows = source.validationErrors;
    else if (Array.isArray(source.issues)) rows = source.issues;
    else if (source.error && typeof source.error === 'object' && Array.isArray(source.error.errors)) rows = source.error.errors;
  }

  return rows
    .map((entry) => {
      if (typeof entry === 'string') {
        return { path: '$', message: safeText(entry, 'Validation error') };
      }
      const row = entry && typeof entry === 'object' ? entry : {};
      const message = safeText(
        row.message ?? row.error ?? row.detail ?? row.reason ?? row.msg,
        ''
      );
      if (!message) return null;
      const path = normalizeValidationPath(
        row.path ?? row.instancePath ?? row.dataPath ?? row.pointer ?? row.field ?? row.location
      );
      return { path, message };
    })
    .filter((row) => !!row);
}

function normalizeConfigEnvelope(rawPayload, { requireJson = false } = {}) {
  const sourceRaw = extractApiData(rawPayload);
  if (typeof sourceRaw === 'string') {
    const rawJson = sourceRaw;
    if (requireJson && !safeText(rawJson, '')) {
      throw new Error('Config payload missing JSON content');
    }
    return {
      rawJson,
      ifMatchHash: '',
      configPath: '',
      updatedAtMs: 0,
    };
  }

  const source = sourceRaw && typeof sourceRaw === 'object' ? sourceRaw : {};
  const ifMatchHash = safeText(
    source.ifMatchHash ?? source.hash ?? source.etag ?? source.contentHash ?? source.matchHash,
    ''
  );
  const configPath = safeText(source.configPath ?? source.path ?? source.filePath ?? source.file, '');
  const updatedAtMs = Math.max(
    0,
    toNumber(source.updatedAtMs ?? source.updatedAt ?? source.savedAtMs ?? source.fetchedAtMs, 0)
  );

  let rawJson = '';
  const stringCandidates = [
    source.rawJson,
    source.rawConfig,
    source.configText,
    source.raw,
    source.text,
    source.content,
  ];
  for (const candidate of stringCandidates) {
    if (typeof candidate !== 'string') continue;
    if (safeText(candidate, '')) {
      rawJson = candidate;
      break;
    }
  }

  if (!safeText(rawJson, '')) {
    let configObject = null;
    if (source.config && typeof source.config === 'object') configObject = source.config;
    else if (source.value && typeof source.value === 'object') configObject = source.value;
    else if (source.json && typeof source.json === 'object') configObject = source.json;
    else if (source.contents && typeof source.contents === 'object') configObject = source.contents;
    else if (!Array.isArray(source)) {
      const metaKeys = new Set([
        'ifMatchHash',
        'hash',
        'etag',
        'contentHash',
        'matchHash',
        'configPath',
        'path',
        'filePath',
        'file',
        'updatedAtMs',
        'updatedAt',
        'savedAtMs',
        'fetchedAtMs',
        'ok',
        'error',
        'detail',
        'code',
        'errors',
        'validationErrors',
        'issues',
      ]);
      const hasConfigKeys = Object.keys(source).some((key) => !metaKeys.has(key));
      if (hasConfigKeys) configObject = source;
    }
    if (configObject) {
      try {
        rawJson = JSON.stringify(configObject, null, 2);
      } catch {
        rawJson = '';
      }
    }
  }

  if (requireJson && !safeText(rawJson, '')) {
    throw new Error('Config payload missing JSON content');
  }

  return {
    rawJson,
    ifMatchHash,
    configPath,
    updatedAtMs,
  };
}

function buildConfigRequestPayload(parsedConfig) {
  const payload = {
    config: parsedConfig,
    rawJson: `${modalState.configEditorText ?? ''}`,
  };
  const ifMatchHash = safeText(modalState.configIfMatchHash, '');
  if (ifMatchHash) {
    payload.ifMatchHash = ifMatchHash;
  }
  return payload;
}

function parseConfigEditorJson() {
  try {
    const value = JSON.parse(`${modalState.configEditorText ?? ''}`);
    return { ok: true, value };
  } catch (err) {
    modalState.configValidationErrors = [];
    setConfigResultBanner('error', `MALFORMED JSON - ${safeText(err?.message, 'Unable to parse config JSON')}`);
    return { ok: false, value: null };
  }
}

function toBoolLike(value) {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value > 0;
  const text = safeText(value, '').toLowerCase();
  return text === 'true' || text === '1' || text === 'yes' || text === 'completed' || text === 'done';
}

function normalizeAchievements(rawAchievements) {
  if (!Array.isArray(rawAchievements)) return [];

  return rawAchievements
    .map((entry, idx) => {
      const row = entry && typeof entry === 'object' ? entry : {};
      const progress = row.progress && typeof row.progress === 'object' ? row.progress : {};
      const code = safeText(row.code ?? row.id ?? row.name, `achievement-${idx + 1}`);
      const title = safeText(row.title ?? row.name ?? row.label, code);
      const progressCurrent = Math.max(
        0,
        toNumber(row.current ?? row.value ?? row.count ?? progress.current ?? progress.value, 0)
      );
      const progressTotal = Math.max(
        0,
        toNumber(row.total ?? row.target ?? row.max ?? progress.total ?? progress.target ?? progress.max, 0)
      );
      const pct = Math.max(0, Math.min(100, toNumber(
        row.pct ?? row.percent ?? row.progressPct ?? progress.pct ?? progress.percent,
        progressTotal > 0 ? statPct(progressCurrent, progressTotal) : 0
      )));
      const completed = toBoolLike(row.completed ?? row.isCompleted ?? row.done)
        || safeText(row.status, '').toLowerCase() === 'completed'
        || (progressTotal > 0 && progressCurrent >= progressTotal);

      return {
        code,
        title,
        completed,
        progressCurrent,
        progressTotal,
        pct,
        searchText: `${code} ${title}`.toLowerCase(),
      };
    })
    .sort((a, b) => Number(b.completed) - Number(a.completed) || b.pct - a.pct || a.code.localeCompare(b.code));
}

function normalizeAchievementSummary(rawSummary, achievementRows) {
  const source = rawSummary && typeof rawSummary === 'object'
    ? (rawSummary.summary && typeof rawSummary.summary === 'object' ? rawSummary.summary : rawSummary)
    : {};

  const derivedCompleted = achievementRows.filter((row) => row.completed).length;
  const derivedTotal = achievementRows.length;
  let total = Math.max(
    0,
    toNumber(
      source.total ?? source.totalCount ?? source.totalAvailable ?? source.available ?? source.achievementsTotal,
      derivedTotal
    )
  );
  let completed = Math.max(
    0,
    toNumber(source.completed ?? source.completedCount ?? source.totalCompleted ?? source.done, derivedCompleted)
  );

  if (total === 0 && derivedTotal > 0) total = derivedTotal;
  if (completed > total && total > 0) completed = total;

  return {
    account: safeText(source.account ?? source.username ?? source.accountName ?? source.name, ''),
    completed,
    total,
  };
}

function getAchievementFilterValue() {
  return ACHIEVEMENT_FILTER_LABELS[modalState.achievementFilter] ? modalState.achievementFilter : 'all';
}

function getAchievementState(row) {
  if (row.completed) return 'completed';
  if (row.progressCurrent > 0 || row.pct > 0) return 'in-progress';
  return 'not-started';
}

function getAchievementProgressText(row) {
  if (row.progressTotal > 0) {
    const pct = row.completed ? 100 : Math.max(0, Math.min(100, Math.round(row.pct)));
    return `${formatNumberish(row.progressCurrent, '0')} / ${formatNumberish(row.progressTotal, '0')} (${pct}%)`;
  }
  if (row.progressCurrent > 0) {
    return formatNumberish(row.progressCurrent, '0');
  }
  return '--';
}

function filterAchievements(rows) {
  const filter = getAchievementFilterValue();
  const needle = `${modalState.achievementSearch ?? ''}`.trim().toLowerCase();

  return rows.filter((row) => {
    const state = getAchievementState(row);
    if (filter === 'completed' && state !== 'completed') return false;
    if (filter === 'in-progress' && state !== 'in-progress') return false;
    if (needle && !row.searchText.includes(needle)) return false;
    return true;
  });
}

function isModalOpen() {
  return !!modalState.activeCharacterName && !!modalState.activeKind && modalRefs.host && !modalRefs.host.hidden;
}

function getModalBannerState() {
  if (modalState.activeKind === 'config') {
    return modalState.configResultBanner;
  }
  if (modalState.activeKind === 'achiev') return null;

  const snapshotChar = appState.characters.get(modalState.activeCharacterName);
  const identity = modalState.detail?.identity || {};
  const stale = !!snapshotChar?.stale || !!identity?.stale;
  const status = safeText(identity?.status, snapshotChar?.status);
  const offline = !!snapshotChar?.offline || (status && status !== 'running');

  if (!offline && !stale) return null;
  if (offline && stale) {
    return {
      tone: 'offline',
      text: 'OFFLINE / STALE - showing last known detail while runtime updates are delayed.',
    };
  }
  if (offline) {
    return {
      tone: 'offline',
      text: 'OFFLINE - runtime is not actively reporting for this character.',
    };
  }
  return {
    tone: 'stale',
    text: 'STALE - detail may lag until the next fresh runtime snapshot.',
  };
}

function renderSkillsModal(detail) {
  const rows = normalizeSkills(detail?.skills);
  if (rows.length === 0) {
    return '<div class="modal-empty">No skills available for this character.</div>';
  }

  const items = rows.map((item) => `
    <div class="modal-list-item">
      <span class="modal-list-main">${escapeHtml(item.code)}</span>
      <span class="modal-list-tag">LV ${formatNumberish(item.level, '0')}</span>
      <span class="modal-list-tag">${formatNumberish(item.xp, '0')} / ${formatNumberish(item.maxXp, '0')} (${item.pct.toFixed(0)}%)</span>
    </div>
  `).join('');

  return `
    <section class="modal-section">
      <h3 class="modal-section-title">Skill Breakdown</h3>
      <div class="modal-list">${items}</div>
    </section>
  `;
}

function renderInventoryModal(detail) {
  const rows = normalizeInventory(detail?.inventory);
  if (rows.length === 0) {
    return '<div class="modal-empty">Inventory is empty.</div>';
  }

  const items = rows.map((item) => `
    <div class="modal-list-item">
      <span class="modal-list-main">${escapeHtml(item.code)}</span>
      <span class="modal-list-slot">SLOT ${formatNumberish(item.slotIndex, '-')}</span>
      <span class="modal-list-tag">x${formatNumberish(item.quantity, '0')}</span>
    </div>
  `).join('');

  return `
    <section class="modal-section">
      <h3 class="modal-section-title">Inventory Slots</h3>
      <div class="modal-list">${items}</div>
    </section>
  `;
}

function renderEquipmentModal(detail) {
  const rows = normalizeEquipment(detail?.equipment);
  if (rows.length === 0) {
    return '<div class="modal-empty">No equipment data available.</div>';
  }

  const items = rows.map((item) => `
    <div class="modal-list-item modal-list-item--two">
      <span class="modal-list-main">${escapeHtml(item.slot)}: ${escapeHtml(item.code)}</span>
      <span class="modal-list-tag">${item.quantity > 0 ? `x${formatNumberish(item.quantity, '1')}` : 'EMPTY'}</span>
    </div>
  `).join('');

  return `
    <section class="modal-section">
      <h3 class="modal-section-title">Equipped Items</h3>
      <div class="modal-list">${items}</div>
    </section>
  `;
}

function renderStatsModal(detail) {
  const stats = detail?.stats && typeof detail.stats === 'object' ? detail.stats : {};
  const identity = detail?.identity && typeof detail.identity === 'object' ? detail.identity : {};
  const activeChar = appState.characters.get(modalState.activeCharacterName);
  const taskText = safeText(
    stats?.task?.label ?? stats?.taskLabel ?? stats?.task?.name ?? activeChar?.taskLabel,
    '--'
  );
  const pos = stats?.position && typeof stats.position === 'object'
    ? `${stats.position.x ?? '--'}, ${stats.position.y ?? '--'}${stats.position.layer != null ? ` @ ${stats.position.layer}` : ''}`
    : '--';
  const cards = [
    { label: 'Status', value: safeText(identity?.status, safeText(activeChar?.status, '--')) },
    { label: 'Level', value: formatNumberish(identity?.level ?? stats?.level ?? activeChar?.level, '--') },
    { label: 'HP', value: `${formatNumberish(stats?.hp ?? activeChar?.hp, '--')} / ${formatNumberish(stats?.maxHp ?? activeChar?.maxHp, '--')}` },
    { label: 'XP', value: `${formatNumberish(stats?.xp ?? activeChar?.xp, '--')} / ${formatNumberish(stats?.maxXp ?? activeChar?.maxXp, '--')}` },
    { label: 'Gold', value: formatNumberish(stats?.gold, '--') },
    { label: 'Position', value: pos },
    { label: 'Task', value: taskText },
    { label: 'Updated', value: formatTime(detail?.updatedAtMs) },
  ];
  const logs = normalizeLogHistory(detail?.logHistory).slice(0, 12);

  const hasStats = cards.some((card) => hasMeaningfulStatValue(card.value));
  if (!hasStats && logs.length === 0) {
    return '<div class="modal-empty">No stats available for this character.</div>';
  }

  const cardHtml = cards.map((card) => `
    <article class="modal-stat">
      <div class="modal-stat-label">${escapeHtml(card.label)}</div>
      <div class="modal-stat-value">${escapeHtml(card.value)}</div>
    </article>
  `).join('');

  const logHtml = logs.length > 0
    ? `
      <section class="modal-section">
        <h3 class="modal-section-title">Recent Log History</h3>
        <div class="modal-list">
          ${logs.map((entry) => `
            <div class="modal-list-item modal-list-item--two">
              <span class="modal-list-main">${escapeHtml(entry.line)}</span>
              <span class="modal-list-tag">${escapeHtml(entry.level.toUpperCase())} ${escapeHtml(formatTime(entry.atMs))}</span>
            </div>
          `).join('')}
        </div>
      </section>
    `
    : '';

  return `
    <section class="modal-section">
      <h3 class="modal-section-title">Runtime Stats</h3>
      <div class="modal-grid">${cardHtml}</div>
    </section>
    ${logHtml}
  `;
}

function renderAchievementsModal(detail) {
  const summary = detail?.summary && typeof detail.summary === 'object' ? detail.summary : {};
  const completed = Math.max(0, toNumber(summary.completed, 0));
  const total = Math.max(completed, toNumber(summary.total, 0));
  const completionPct = total > 0 ? Math.round((completed / total) * 100) : 0;
  const filter = getAchievementFilterValue();
  const searchValue = `${modalState.achievementSearch ?? ''}`;

  const filterButtons = Object.entries(ACHIEVEMENT_FILTER_LABELS).map(([value, label]) => `
    <button
      type="button"
      class="achievement-filter-btn${value === filter ? ' is-active' : ''}"
      data-achievement-filter="${value}"
    >${escapeHtml(label.toUpperCase())}</button>
  `).join('');

  return `
    <section class="modal-section">
      <h3 class="modal-section-title">Account Totals</h3>
      <div class="modal-grid">
        <article class="modal-stat">
          <div class="modal-stat-label">Completed</div>
          <div class="modal-stat-value">${formatNumberish(completed, '0')}</div>
        </article>
        <article class="modal-stat">
          <div class="modal-stat-label">Total Available</div>
          <div class="modal-stat-value">${formatNumberish(total, '0')}</div>
        </article>
        <article class="modal-stat">
          <div class="modal-stat-label">Completion</div>
          <div class="modal-stat-value">${formatNumberish(completionPct, '0')}%</div>
        </article>
      </div>
    </section>
    <section class="modal-section">
      <h3 class="modal-section-title">Achievements</h3>
      <div class="achievement-toolbar">
        <div class="achievement-filter-group" role="tablist" aria-label="Achievement filters">
          ${filterButtons}
        </div>
        <label class="achievement-search">
          <span class="achievement-search-label">SEARCH</span>
          <input
            type="search"
            class="achievement-search-input"
            data-achievement-search
            placeholder="Code or title"
            value="${escapeHtml(searchValue)}"
            autocomplete="off"
          >
        </label>
      </div>
      <div class="achievement-result-count" data-achievement-result-count></div>
      <div class="modal-list" data-achievement-list></div>
    </section>
  `;
}

function renderConfigModal(detail) {
  const configPath = safeText(detail?.configPath, '--');
  const hash = safeText(modalState.configIfMatchHash, '--');
  const updatedAt = formatTime(detail?.updatedAtMs);
  const editorText = `${modalState.configEditorText ?? ''}`;
  const validationErrors = Array.isArray(modalState.configValidationErrors)
    ? modalState.configValidationErrors
    : [];
  const busy = modalState.configBusy;
  const busyAttr = busy ? ' disabled' : '';

  const validationHtml = validationErrors.length > 0
    ? `
      <section class="modal-section">
        <h3 class="modal-section-title">Validation Errors</h3>
        <div class="config-validation-list">
          ${validationErrors.map((row) => `
            <div class="config-validation-item">
              <span class="config-validation-path">${escapeHtml(safeText(row.path, '$'))}</span>
              <span class="config-validation-message">${escapeHtml(safeText(row.message, 'Validation error'))}</span>
            </div>
          `).join('')}
        </div>
      </section>
    `
    : '';

  return `
    <div class="config-editor">
      <section class="modal-section">
        <h3 class="modal-section-title">Active Config</h3>
        <div class="config-editor-meta">
          <article class="modal-stat">
            <div class="modal-stat-label">Path</div>
            <div class="modal-stat-value">${escapeHtml(configPath)}</div>
          </article>
          <article class="modal-stat">
            <div class="modal-stat-label">If-Match Hash</div>
            <div class="modal-stat-value">${escapeHtml(hash)}</div>
          </article>
        </div>
        <div class="achievement-result-count">Loaded ${escapeHtml(updatedAt)}</div>
      </section>
      <section class="modal-section">
        <h3 class="modal-section-title">Raw JSON</h3>
        <textarea
          class="config-editor-textarea"
          data-config-json
          spellcheck="false"
          autocapitalize="off"
          autocomplete="off"
          autocorrect="off"
          aria-label="Raw config JSON editor"${busyAttr}
        >${escapeHtml(editorText)}</textarea>
      </section>
      <section class="modal-section">
        <h3 class="modal-section-title">Actions</h3>
        <div class="config-editor-actions">
          <button type="button" class="config-editor-btn" data-config-action="validate"${busyAttr}>VALIDATE</button>
          <button type="button" class="config-editor-btn" data-config-action="save"${busyAttr}>SAVE</button>
        </div>
      </section>
      ${validationHtml}
    </div>
  `;
}

function renderAchievementsListInPlace() {
  if (!modalRefs.content || modalState.activeKind !== 'achiev' || modalState.status !== 'ready' || !modalState.detail) {
    return;
  }

  const listHost = modalRefs.content.querySelector('[data-achievement-list]');
  const countHost = modalRefs.content.querySelector('[data-achievement-result-count]');
  if (!listHost) return;

  const rows = Array.isArray(modalState.detail.achievements) ? modalState.detail.achievements : [];
  const visibleRows = filterAchievements(rows);
  const activeFilter = getAchievementFilterValue();

  modalRefs.content.querySelectorAll('button[data-achievement-filter]').forEach((button) => {
    const value = safeText(button.dataset.achievementFilter, '');
    button.classList.toggle('is-active', value === activeFilter);
  });

  if (countHost) {
    if (rows.length === 0) {
      countHost.textContent = 'No achievements available.';
    } else {
      countHost.textContent = `Showing ${formatNumberish(visibleRows.length, '0')} of ${formatNumberish(rows.length, '0')} achievements.`;
    }
  }

  if (rows.length === 0) {
    listHost.innerHTML = '<div class="modal-empty">No achievements available for this account.</div>';
    return;
  }

  if (visibleRows.length === 0) {
    listHost.innerHTML = '<div class="modal-empty">No achievements match the selected filter or search.</div>';
    return;
  }

  listHost.innerHTML = visibleRows.map((row) => {
    const state = getAchievementState(row);
    const statusLabel = state === 'completed'
      ? 'COMPLETED'
      : (state === 'in-progress' ? 'IN PROGRESS' : 'NOT STARTED');

    return `
      <div class="modal-list-item modal-list-item--two">
        <span class="modal-list-main achievement-list-main">
          <span class="achievement-code">${escapeHtml(row.code)}</span>
          <span class="achievement-title">${escapeHtml(row.title)}</span>
        </span>
        <span class="achievement-progress">
          <span class="achievement-status is-${state}">${statusLabel}</span>
          <span class="modal-list-tag">${escapeHtml(getAchievementProgressText(row))}</span>
        </span>
      </div>
    `;
  }).join('');
}

function renderModalContent() {
  if (!modalRefs.content) return;

  const kindLabel = MODAL_KIND_LABELS[modalState.activeKind] || 'Detail';
  if (modalState.status === 'loading') {
    modalRefs.content.innerHTML = `<div class="modal-state">Loading ${escapeHtml(kindLabel)}...</div>`;
    return;
  }

  if (modalState.status === 'error') {
    const message = safeText(modalState.errorText, 'Unknown error');
    modalRefs.content.innerHTML = `
      <div class="modal-error">
        Unable to load ${escapeHtml(kindLabel)}.
        <span class="modal-log-line">${escapeHtml(message)}</span>
      </div>
    `;
    return;
  }

  if (modalState.status !== 'ready' || !modalState.detail) {
    modalRefs.content.innerHTML = '<div class="modal-state">Select a detail view.</div>';
    return;
  }

  if (modalState.activeKind === 'skills') {
    modalRefs.content.innerHTML = renderSkillsModal(modalState.detail);
    return;
  }
  if (modalState.activeKind === 'inven') {
    modalRefs.content.innerHTML = renderInventoryModal(modalState.detail);
    return;
  }
  if (modalState.activeKind === 'equip') {
    modalRefs.content.innerHTML = renderEquipmentModal(modalState.detail);
    return;
  }
  if (modalState.activeKind === 'achiev') {
    modalRefs.content.innerHTML = renderAchievementsModal(modalState.detail);
    renderAchievementsListInPlace();
    return;
  }
  if (modalState.activeKind === 'config') {
    modalRefs.content.innerHTML = renderConfigModal(modalState.detail);
    return;
  }
  modalRefs.content.innerHTML = renderStatsModal(modalState.detail);
}

function renderModal() {
  if (!isModalOpen()) return;

  const label = MODAL_KIND_LABELS[modalState.activeKind] || 'Detail';
  if (modalRefs.kind) modalRefs.kind.textContent = label.toUpperCase();
  if (modalRefs.title) {
    if (modalState.activeKind === 'achiev') {
      const accountName = safeText(modalState.detail?.summary?.account, 'Account');
      modalRefs.title.textContent = `${accountName} - ${label}`;
    } else if (modalState.activeKind === 'config') {
      modalRefs.title.textContent = `Runtime Config - ${label}`;
    } else {
      modalRefs.title.textContent = `${modalState.activeCharacterName} - ${label}`;
    }
  }

  if (modalRefs.banner) {
    const banner = getModalBannerState();
    if (!banner) {
      modalRefs.banner.hidden = true;
      modalRefs.banner.className = 'modal-banner';
      modalRefs.banner.textContent = '';
    } else {
      modalRefs.banner.hidden = false;
      modalRefs.banner.className = `modal-banner ${banner.tone}`;
      modalRefs.banner.textContent = banner.text;
    }
  }

  renderModalContent();
}

function abortModalFetch() {
  if (modalState.fetchController) {
    modalState.fetchController.abort();
    modalState.fetchController = null;
  }
  if (modalState.configActionController) {
    modalState.configActionController.abort();
    modalState.configActionController = null;
    modalState.configBusy = false;
  }
}

async function fetchCharacterDetail(name) {
  if (!isModalOpen() || modalState.activeCharacterName !== name) return;

  abortModalFetch();
  const controller = new AbortController();
  const seq = modalState.fetchSeq + 1;
  modalState.fetchSeq = seq;
  modalState.fetchController = controller;
  modalState.status = 'loading';
  modalState.errorText = '';
  renderModal();

  try {
    const res = await fetch(`/api/ui/character/${encodeURIComponent(name)}`, {
      cache: 'no-store',
      signal: controller.signal,
    });

    const payload = await res.json().catch(() => null);
    if (!res.ok) {
      const errText = safeText(payload?.error, `HTTP ${res.status}`);
      const errDetail = safeText(payload?.detail, '');
      let message = errDetail ? `${errText}: ${errDetail}` : errText;
      if (res.status === 404 && errText === 'not_found') {
        message = `${message}. Restart runtime to load latest dashboard routes.`;
      }
      throw new Error(message);
    }

    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeCharacterName !== name) {
      return;
    }

    modalState.detail = payload || {};
    modalState.status = 'ready';
    modalState.errorText = '';
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeCharacterName !== name) {
      return;
    }
    modalState.status = 'error';
    modalState.errorText = safeText(err?.message, 'Failed to fetch character detail');
  } finally {
    if (modalState.fetchController === controller) {
      modalState.fetchController = null;
    }
    renderModal();
  }
}

function buildApiErrorMessage(response, payload, prefix) {
  const data = extractApiData(payload);
  const base = safeText(payload?.error ?? data?.error, `HTTP ${response.status}`);
  const detail = safeText(payload?.detail ?? data?.detail, '');
  return detail ? `${prefix}: ${base}: ${detail}` : `${prefix}: ${base}`;
}

async function fetchControlStatus({ silentErrors = false } = {}) {
  if (controlState.statusController) {
    controlState.statusController.abort();
  }

  const controller = new AbortController();
  const seq = controlState.statusSeq + 1;
  controlState.statusSeq = seq;
  controlState.statusController = controller;

  try {
    const res = await fetch('/api/control/status', {
      cache: 'no-store',
      signal: controller.signal,
    });
    const payloadRaw = await res.json().catch(() => null);
    if (controlState.statusSeq !== seq) return;

    if (res.status === 404) {
      runtimeFeatures.controlPanelAvailable = false;
      controlState.statusSnapshot = null;
      controlState.statusError = '';
      setControlOperationState('idle');
      setControlResultBanner('', '');
      stopControlStatusPolling();
      renderControlPanel();
      return;
    }

    runtimeFeatures.controlPanelAvailable = true;

    if (!res.ok) {
      const message = buildApiErrorMessage(res, payloadRaw, 'Control status failed');
      controlState.statusError = message;
      controlState.statusSnapshot = {
        lifecycle: 'error',
        inFlight: false,
        operationAction: '',
        updatedAtMs: Date.now(),
        detail: message,
      };
      if (!silentErrors) {
        setControlResultBanner('warning', `CONTROL STATUS FAILURE - ${message}`);
      }
      renderControlPanel();
      return;
    }

    controlState.statusSnapshot = normalizeControlStatusSnapshot(payloadRaw);
    controlState.statusError = '';
    renderControlPanel();
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (controlState.statusSeq !== seq) return;

    controlState.statusError = safeText(err?.message, 'Control status request failed');
    if (!controlState.statusSnapshot) {
      controlState.statusSnapshot = {
        lifecycle: 'unknown',
        inFlight: false,
        operationAction: '',
        updatedAtMs: Date.now(),
        detail: '',
      };
    }
    if (!silentErrors) {
      setControlResultBanner('warning', `CONTROL STATUS FAILURE - ${controlState.statusError}`);
    }
    renderControlPanel();
  } finally {
    if (controlState.statusController === controller) {
      controlState.statusController = null;
    }
  }
}

async function runRuntimeControlAction(action) {
  const normalizedAction = normalizeControlAction(action, '');
  if (!normalizedAction || !runtimeFeatures.controlPanelAvailable) return;
  if (controlState.operationState === 'in-flight') return;
  if (controlState.statusSnapshot?.inFlight) {
    setControlOperationState('failure', { action: normalizedAction });
    setControlResultBanner('warning', 'CONTROL LOCKED - another runtime operation is already in-flight.');
    renderControlPanel();
    return;
  }

  if (controlState.actionController) {
    controlState.actionController.abort();
  }
  const controller = new AbortController();
  controlState.actionController = controller;

  const actionLabel = formatUpperToken(getControlActionLabel(normalizedAction, normalizedAction), 'CONTROL');
  setControlOperationState('in-flight', { action: normalizedAction });
  setControlResultBanner('info', `${actionLabel} IN-FLIGHT...`);
  renderControlPanel();

  try {
    const res = await fetch(CONTROL_ACTION_ENDPOINTS[normalizedAction], {
      method: 'POST',
      cache: 'no-store',
      signal: controller.signal,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    const payloadRaw = await res.json().catch(() => null);

    if (res.status === 404) {
      runtimeFeatures.controlPanelAvailable = false;
      setControlOperationState('failure', { action: normalizedAction });
      setControlResultBanner('error', 'CONTROL UNAVAILABLE (404) - runtime control routes were not found.');
      stopControlStatusPolling();
      renderControlPanel();
      return;
    }

    if (!res.ok) {
      const message = buildApiErrorMessage(res, payloadRaw, `${getControlActionLabel(normalizedAction, 'Control action')} failed`);
      setControlOperationState('failure', { action: normalizedAction });
      setControlResultBanner('error', `${actionLabel} FAILURE - ${message}`);
      renderControlPanel();
      await fetchControlStatus({ silentErrors: true });
      return;
    }

    const payload = extractApiData(payloadRaw);
    const detail = safeText(
      payload?.detail ?? payloadRaw?.detail ?? payload?.message ?? payloadRaw?.message,
      ''
    );

    setControlOperationState('success', { action: normalizedAction });
    setControlResultBanner('success', `${actionLabel} SUCCESS${detail ? ` - ${detail}` : ''}.`);
    renderControlPanel();
    await fetchControlStatus({ silentErrors: true });
  } catch (err) {
    if (err?.name === 'AbortError') return;
    setControlOperationState('failure', { action: normalizedAction });
    setControlResultBanner('error', `${actionLabel} FAILURE - ${safeText(err?.message, 'Request failed')}`);
    renderControlPanel();
    await fetchControlStatus({ silentErrors: true });
  } finally {
    if (controlState.actionController === controller) {
      controlState.actionController = null;
    }
    renderControlPanel();
  }
}

async function fetchConfigDetail() {
  if (!isModalOpen() || modalState.activeKind !== 'config') return;

  abortModalFetch();
  const controller = new AbortController();
  const seq = modalState.fetchSeq + 1;
  modalState.fetchSeq = seq;
  modalState.fetchController = controller;
  modalState.status = 'loading';
  modalState.errorText = '';
  modalState.configBusy = false;
  modalState.configValidationErrors = [];
  setConfigResultBanner('', '');
  renderModal();

  try {
    const res = await fetch('/api/config', {
      cache: 'no-store',
      signal: controller.signal,
    });
    const payloadRaw = await res.json().catch(() => null);
    if (!res.ok) {
      throw new Error(buildApiErrorMessage(res, payloadRaw, 'Config load failed'));
    }

    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeKind !== 'config') {
      return;
    }

    const envelope = normalizeConfigEnvelope(payloadRaw, { requireJson: true });
    modalState.detail = {
      configPath: envelope.configPath,
      updatedAtMs: envelope.updatedAtMs,
    };
    modalState.configEditorText = envelope.rawJson;
    modalState.configIfMatchHash = envelope.ifMatchHash;
    modalState.status = 'ready';
    modalState.errorText = '';
    modalState.configValidationErrors = [];
    setConfigResultBanner('', '');
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeKind !== 'config') {
      return;
    }
    modalState.status = 'error';
    modalState.errorText = safeText(err?.message, 'Failed to load config');
  } finally {
    if (modalState.fetchController === controller) {
      modalState.fetchController = null;
    }
    renderModal();
  }
}

async function runConfigValidate() {
  if (!isModalOpen() || modalState.activeKind !== 'config' || modalState.status !== 'ready' || modalState.configBusy) {
    return;
  }

  const parsed = parseConfigEditorJson();
  if (!parsed.ok) {
    renderModal();
    return;
  }

  if (modalState.configActionController) {
    modalState.configActionController.abort();
  }
  const controller = new AbortController();
  modalState.configActionController = controller;
  modalState.configBusy = true;
  renderModal();

  try {
    const res = await fetch('/api/config/validate', {
      method: 'POST',
      cache: 'no-store',
      signal: controller.signal,
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(buildConfigRequestPayload(parsed.value)),
    });

    const payloadRaw = await res.json().catch(() => null);
    if (!isModalOpen() || modalState.activeKind !== 'config') return;

    const payload = extractApiData(payloadRaw);
    const errors = normalizeValidationErrors(payloadRaw);
    const explicitOk = payload && typeof payload === 'object' && typeof payload.ok === 'boolean'
      ? payload.ok
      : null;
    const validationPassed = res.ok && explicitOk !== false && errors.length === 0;

    if (validationPassed) {
      modalState.configValidationErrors = [];
      setConfigResultBanner('success', 'VALIDATE SUCCESS - config schema checks passed.');
      return;
    }

    modalState.configValidationErrors = errors;
    if (modalState.configValidationErrors.length === 0) {
      const fallbackMessage = safeText(
        payload?.detail ?? payloadRaw?.detail ?? payload?.error ?? payloadRaw?.error,
        'Validation failed'
      );
      modalState.configValidationErrors = [{ path: '$', message: fallbackMessage }];
    }
    setConfigResultBanner('warning', 'VALIDATE FAILURE - review inline path + message errors.');
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (!isModalOpen() || modalState.activeKind !== 'config') return;
    modalState.configValidationErrors = [];
    setConfigResultBanner('error', `VALIDATE FAILURE - ${safeText(err?.message, 'Request failed')}`);
  } finally {
    if (modalState.configActionController === controller) {
      modalState.configActionController = null;
      modalState.configBusy = false;
    }
    renderModal();
  }
}

async function runConfigSave() {
  if (!isModalOpen() || modalState.activeKind !== 'config' || modalState.status !== 'ready' || modalState.configBusy) {
    return;
  }

  const parsed = parseConfigEditorJson();
  if (!parsed.ok) {
    renderModal();
    return;
  }

  if (modalState.configActionController) {
    modalState.configActionController.abort();
  }
  const controller = new AbortController();
  modalState.configActionController = controller;
  modalState.configBusy = true;
  renderModal();

  try {
    const headers = {
      'Content-Type': 'application/json',
    };
    const ifMatchHash = safeText(modalState.configIfMatchHash, '');
    if (ifMatchHash) {
      headers['If-Match'] = ifMatchHash;
    }

    const res = await fetch('/api/config', {
      method: 'PUT',
      cache: 'no-store',
      signal: controller.signal,
      headers,
      body: JSON.stringify(buildConfigRequestPayload(parsed.value)),
    });
    const payloadRaw = await res.json().catch(() => null);
    if (!isModalOpen() || modalState.activeKind !== 'config') return;

    if (res.status === 409) {
      modalState.configValidationErrors = normalizeValidationErrors(payloadRaw);
      if (modalState.configValidationErrors.length === 0) {
        const detail = safeText(payloadRaw?.detail ?? extractApiData(payloadRaw)?.detail, '');
        if (detail) modalState.configValidationErrors = [{ path: '$', message: detail }];
      }
      setConfigResultBanner('warning', 'SAVE CONFLICT (409) - loaded hash is stale; reload before retry.');
      return;
    }

    if (!res.ok) {
      const errors = normalizeValidationErrors(payloadRaw);
      modalState.configValidationErrors = errors;
      if (modalState.configValidationErrors.length === 0) {
        modalState.configValidationErrors = [{
          path: '$',
          message: buildApiErrorMessage(res, payloadRaw, 'Save failed'),
        }];
      }
      setConfigResultBanner('error', 'SAVE FAILURE - config was not persisted.');
      return;
    }

    const payload = extractApiData(payloadRaw);
    if (payload && typeof payload === 'object' && payload.ok === false) {
      modalState.configValidationErrors = normalizeValidationErrors(payloadRaw);
      if (modalState.configValidationErrors.length === 0) {
        const detail = safeText(payload.detail, 'Save failed');
        modalState.configValidationErrors = [{ path: '$', message: detail }];
      }
      setConfigResultBanner('error', 'SAVE FAILURE - config was not persisted.');
      return;
    }

    const envelope = normalizeConfigEnvelope(payloadRaw, { requireJson: false });
    if (safeText(envelope.rawJson, '')) {
      modalState.configEditorText = envelope.rawJson;
    }
    if (safeText(envelope.ifMatchHash, '')) {
      modalState.configIfMatchHash = envelope.ifMatchHash;
    }
    modalState.detail = {
      configPath: envelope.configPath || safeText(modalState.detail?.configPath, ''),
      updatedAtMs: envelope.updatedAtMs || Date.now(),
    };
    modalState.configValidationErrors = [];
    setConfigResultBanner('success', 'SAVE SUCCESS - config persisted.');
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (!isModalOpen() || modalState.activeKind !== 'config') return;
    modalState.configValidationErrors = [];
    setConfigResultBanner('error', `SAVE FAILURE - ${safeText(err?.message, 'Request failed')}`);
  } finally {
    if (modalState.configActionController === controller) {
      modalState.configActionController = null;
      modalState.configBusy = false;
    }
    renderModal();
  }
}

async function fetchAccountAchievementsDetail() {
  if (!isModalOpen() || modalState.activeKind !== 'achiev') return;

  abortModalFetch();
  const controller = new AbortController();
  const seq = modalState.fetchSeq + 1;
  modalState.fetchSeq = seq;
  modalState.fetchController = controller;
  modalState.status = 'loading';
  modalState.errorText = '';
  renderModal();

  try {
    const [summaryRes, achievementsRes] = await Promise.all([
      fetch('/api/ui/account/summary', {
        cache: 'no-store',
        signal: controller.signal,
      }),
      fetch('/api/ui/account/achievements', {
        cache: 'no-store',
        signal: controller.signal,
      }),
    ]);

    const [summaryPayloadRaw, achievementsPayloadRaw] = await Promise.all([
      summaryRes.json().catch(() => null),
      achievementsRes.json().catch(() => null),
    ]);

    if (!summaryRes.ok) {
      throw new Error(buildApiErrorMessage(summaryRes, summaryPayloadRaw, 'Account summary request failed'));
    }
    if (!achievementsRes.ok) {
      throw new Error(buildApiErrorMessage(achievementsRes, achievementsPayloadRaw, 'Achievements request failed'));
    }

    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeKind !== 'achiev') {
      return;
    }

    const summaryPayload = extractApiData(summaryPayloadRaw) || {};
    const achievementsPayload = extractApiData(achievementsPayloadRaw) || {};
    const achievementRows = normalizeAchievements(
      Array.isArray(achievementsPayload)
        ? achievementsPayload
        : (achievementsPayload?.achievements ?? achievementsPayload?.items ?? achievementsPayload?.rows ?? [])
    );
    const summary = normalizeAchievementSummary(summaryPayload, achievementRows);

    modalState.detail = {
      summary,
      achievements: achievementRows,
      updatedAtMs: Math.max(
        0,
        toNumber(achievementsPayload?.updatedAtMs ?? summaryPayload?.updatedAtMs ?? summaryPayload?.updatedAt, 0)
      ),
    };
    modalState.status = 'ready';
    modalState.errorText = '';
  } catch (err) {
    if (err?.name === 'AbortError') return;
    if (!isModalOpen() || modalState.fetchSeq !== seq || modalState.activeKind !== 'achiev') {
      return;
    }
    modalState.status = 'error';
    modalState.errorText = safeText(err?.message, 'Failed to fetch account achievements');
  } finally {
    if (modalState.fetchController === controller) {
      modalState.fetchController = null;
    }
    renderModal();
  }
}

function openCharacterModal(name, kind) {
  if (!name || !MODAL_KIND_LABELS[kind] || !modalRefs.host || !modalRefs.dialog) return;
  if (kind === 'config') {
    openConfigModal();
    return;
  }

  modalState.lastFocusedElement = document.activeElement instanceof HTMLElement
    ? document.activeElement
    : null;
  modalState.activeCharacterName = name;
  modalState.activeKind = kind;
  modalState.status = 'loading';
  modalState.detail = null;
  modalState.errorText = '';
  modalState.activeSnapshotUpdatedAtMs = kind === 'achiev'
    ? 0
    : (appState.characters.get(name)?.lastUpdatedAtMs || 0);
  modalState.achievementFilter = 'all';
  modalState.achievementSearch = '';
  modalState.configEditorText = '';
  modalState.configIfMatchHash = '';
  modalState.configValidationErrors = [];
  modalState.configBusy = false;
  setConfigResultBanner('', '');

  modalRefs.host.hidden = false;
  document.body.classList.add('modal-open');
  renderModal();

  requestAnimationFrame(() => {
    if (modalRefs.closeBtn) modalRefs.closeBtn.focus();
    else modalRefs.dialog.focus();
  });

  if (kind === 'achiev') {
    fetchAccountAchievementsDetail();
  } else {
    fetchCharacterDetail(name);
  }
}

function openConfigModal() {
  if (!modalRefs.host || !modalRefs.dialog) return;

  modalState.lastFocusedElement = document.activeElement instanceof HTMLElement
    ? document.activeElement
    : null;
  modalState.activeCharacterName = CONFIG_MODAL_NAME;
  modalState.activeKind = 'config';
  modalState.status = 'loading';
  modalState.detail = null;
  modalState.errorText = '';
  modalState.activeSnapshotUpdatedAtMs = 0;
  modalState.achievementFilter = 'all';
  modalState.achievementSearch = '';
  modalState.configEditorText = '';
  modalState.configIfMatchHash = '';
  modalState.configValidationErrors = [];
  modalState.configBusy = false;
  setConfigResultBanner('', '');

  modalRefs.host.hidden = false;
  document.body.classList.add('modal-open');
  renderModal();

  requestAnimationFrame(() => {
    if (modalRefs.closeBtn) modalRefs.closeBtn.focus();
    else modalRefs.dialog.focus();
  });

  fetchConfigDetail();
}

function closeCharacterModal({ restoreFocus = true } = {}) {
  if (!modalRefs.host || modalRefs.host.hidden) return;

  abortModalFetch();
  modalRefs.host.hidden = true;
  document.body.classList.remove('modal-open');

  const focusEl = modalState.lastFocusedElement;
  modalState.activeCharacterName = '';
  modalState.activeKind = '';
  modalState.status = 'idle';
  modalState.detail = null;
  modalState.errorText = '';
  modalState.activeSnapshotUpdatedAtMs = 0;
  modalState.lastFocusedElement = null;
  modalState.achievementFilter = 'all';
  modalState.achievementSearch = '';
  modalState.configEditorText = '';
  modalState.configIfMatchHash = '';
  modalState.configValidationErrors = [];
  modalState.configBusy = false;
  setConfigResultBanner('', '');

  if (restoreFocus && focusEl && document.contains(focusEl)) {
    focusEl.focus();
  }
}

function trapModalFocus(event) {
  if (!isModalOpen() || !modalRefs.dialog) return;
  const focusable = [...modalRefs.dialog.querySelectorAll('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])')];
  if (focusable.length === 0) {
    event.preventDefault();
    modalRefs.dialog.focus();
    return;
  }

  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  const active = document.activeElement;
  const inside = modalRefs.dialog.contains(active);

  if (event.shiftKey) {
    if (!inside || active === first) {
      event.preventDefault();
      last.focus();
    }
    return;
  }

  if (!inside || active === last) {
    event.preventDefault();
    first.focus();
  }
}

function onDocumentKeydown(event) {
  if (!isModalOpen()) return;
  if (event.key === 'Escape') {
    event.preventDefault();
    closeCharacterModal();
    return;
  }
  if (event.key === 'Tab') {
    trapModalFocus(event);
  }
}

function onCardActionClick(event) {
  const button = closestFromEventTarget(event, 'button[data-modal-kind]');
  if (!button || button.disabled) return;
  const card = button.closest('.card');
  const name = card?.dataset?.charName;
  const kind = safeText(button.dataset.modalKind, '').toLowerCase();
  if (!name || !MODAL_KIND_LABELS[kind]) return;
  openCharacterModal(name, kind);
}

function onConfigButtonClick() {
  if (!runtimeFeatures.configEditorAvailable) return;
  openConfigModal();
}

function onRuntimeControlButtonClick(event) {
  const button = closestFromEventTarget(event, 'button[data-runtime-control]');
  if (!button || button.disabled) return;

  const action = normalizeControlAction(button.dataset.runtimeControl, '');
  if (!action) return;
  runRuntimeControlAction(action);
}

function onModalContentClick(event) {
  if (!isModalOpen() || modalState.status !== 'ready' || !modalRefs.content) return;

  if (modalState.activeKind === 'achiev') {
    const button = closestFromEventTarget(event, 'button[data-achievement-filter]');
    if (!button || !modalRefs.content.contains(button)) return;

    const nextFilter = safeText(button.dataset.achievementFilter, '').toLowerCase();
    if (!ACHIEVEMENT_FILTER_LABELS[nextFilter]) return;
    if (modalState.achievementFilter === nextFilter) return;

    modalState.achievementFilter = nextFilter;
    renderAchievementsListInPlace();
    return;
  }

  if (modalState.activeKind !== 'config') return;
  const button = closestFromEventTarget(event, 'button[data-config-action]');
  if (!button || !modalRefs.content.contains(button) || button.disabled) return;

  const action = safeText(button.dataset.configAction, '').toLowerCase();
  if (action === 'validate') {
    runConfigValidate();
    return;
  }
  if (action === 'save') {
    runConfigSave();
  }
}

function onModalContentInput(event) {
  if (!isModalOpen() || modalState.status !== 'ready' || !modalRefs.content) return;

  if (modalState.activeKind === 'achiev') {
    const input = closestFromEventTarget(event, 'input[data-achievement-search]');
    if (!input || !modalRefs.content.contains(input)) return;

    modalState.achievementSearch = `${input.value ?? ''}`;
    renderAchievementsListInPlace();
    return;
  }

  if (modalState.activeKind !== 'config') return;
  const editor = closestFromEventTarget(event, 'textarea[data-config-json]');
  if (!editor || !modalRefs.content.contains(editor)) return;

  modalState.configEditorText = `${editor.value ?? ''}`;
}

function maybeRefreshActiveModalFromSnapshot() {
  if (!isModalOpen()) return;
  if (modalState.activeKind === 'achiev' || modalState.activeKind === 'config') return;

  const activeChar = appState.characters.get(modalState.activeCharacterName);
  if (!activeChar) {
    renderModal();
    return;
  }

  const nextUpdatedAtMs = Math.max(0, toNumber(activeChar.lastUpdatedAtMs, 0));
  if (nextUpdatedAtMs > 0 && nextUpdatedAtMs !== modalState.activeSnapshotUpdatedAtMs) {
    modalState.activeSnapshotUpdatedAtMs = nextUpdatedAtMs;
    fetchCharacterDetail(modalState.activeCharacterName);
    return;
  }

  renderModal();
}

function applyConfigFeatureVisibility() {
  if (!modalRefs.configBtn) return;
  modalRefs.configBtn.hidden = !runtimeFeatures.configEditorAvailable;
}

function applyRuntimeControlFeatureVisibility() {
  renderControlPanel();
}

async function probeConfigFeatureAvailability() {
  runtimeFeatures.configEditorAvailable = false;
  applyConfigFeatureVisibility();

  try {
    const res = await fetch('/api/config', { cache: 'no-store' });
    runtimeFeatures.configEditorAvailable = res.status !== 404;
  } catch {
    runtimeFeatures.configEditorAvailable = false;
  }

  applyConfigFeatureVisibility();
}

async function probeControlFeatureAvailability() {
  runtimeFeatures.controlPanelAvailable = false;
  controlState.statusSnapshot = null;
  controlState.statusError = '';
  setControlOperationState('idle');
  setControlResultBanner('', '');
  applyRuntimeControlFeatureVisibility();

  await fetchControlStatus({ silentErrors: true });

  if (runtimeFeatures.controlPanelAvailable) {
    startControlStatusPolling();
  } else {
    stopControlStatusPolling();
  }

  applyRuntimeControlFeatureVisibility();
}

function setupModalFramework() {
  modalRefs.host = document.getElementById('modalHost');
  modalRefs.scrim = document.getElementById('modalScrim');
  modalRefs.dialog = document.getElementById('characterModal');
  modalRefs.kind = document.getElementById('modalKind');
  modalRefs.title = document.getElementById('modalTitle');
  modalRefs.banner = document.getElementById('modalBanner');
  modalRefs.content = document.getElementById('modalContent');
  modalRefs.closeBtn = document.getElementById('modalCloseBtn');
  modalRefs.configBtn = document.getElementById('openConfigBtn');
  controlRefs.restartBtn = document.getElementById('restartBotBtn');
  controlRefs.statusPanel = document.getElementById('controlStatusPanel');
  controlRefs.runtimeState = document.getElementById('controlRuntimeState');
  controlRefs.operationState = document.getElementById('controlOperationState');
  controlRefs.updatedAt = document.getElementById('controlStatusUpdatedAt');
  controlRefs.banner = document.getElementById('controlResultBanner');

  const cardsContainer = document.getElementById('cardsContainer');
  if (cardsContainer) {
    cardsContainer.addEventListener('click', onCardActionClick);
  }
  if (modalRefs.configBtn) {
    modalRefs.configBtn.addEventListener('click', onConfigButtonClick);
  }
  if (controlRefs.restartBtn) {
    controlRefs.restartBtn.addEventListener('click', onRuntimeControlButtonClick);
  }
  if (modalRefs.scrim) {
    modalRefs.scrim.addEventListener('click', () => closeCharacterModal());
  }
  if (modalRefs.closeBtn) {
    modalRefs.closeBtn.addEventListener('click', () => closeCharacterModal());
  }
  if (modalRefs.content) {
    modalRefs.content.addEventListener('click', onModalContentClick);
    modalRefs.content.addEventListener('input', onModalContentInput);
  }
  document.addEventListener('keydown', onDocumentKeydown);
  renderControlPanel();
}

function syncCards() {
  const container = document.getElementById('cardsContainer');
  const nextNames = new Set(appState.order);

  for (const [name, refs] of cardRefs.entries()) {
    if (!nextNames.has(name)) {
      refs.root.remove();
      cardRefs.delete(name);
    }
  }

  appState.order.forEach((name, index) => {
    const char = appState.characters.get(name);
    if (!char) return;

    if (!cardRefs.has(name)) {
      container.appendChild(buildCard(char, index));
    }

    const refs = cardRefs.get(name);
    if (refs && refs.root.parentElement === container) {
      container.appendChild(refs.root);
    }
    applyCharacterState(char);
  });
}

/* ==============================================================
   FLOATING PETALS + INK DROPS
   ============================================================== */
function createPetals() {
  const container = document.getElementById('petalsContainer');

  // Pink petal colors (ink-wash muted pinks)
  const petalColors = ['#d88898', '#e8a8b0', '#c87888', '#d89098', '#e0b0b8'];
  // Ink drop colors
  const inkColors = ['rgba(42, 36, 32, 0.3)', 'rgba(42, 36, 32, 0.25)', 'rgba(42, 36, 32, 0.2)', 'rgba(56, 44, 40, 0.25)'];

  const petalCount = 20;
  const inkCount = 8;

  // Pink petals
  for (let i = 0; i < petalCount; i++) {
    const petal = document.createElement('div');
    petal.className = 'petal petal--blossom';
    const size = Math.random() > 0.5 ? 4 : 3;
    petal.style.width = size + 'px';
    petal.style.height = size + 'px';
    petal.style.backgroundColor = petalColors[Math.floor(Math.random() * petalColors.length)];
    petal.style.left = Math.random() * 100 + '%';
    petal.style.top = -10 + 'px';
    petal.style.animationDuration = (8 + Math.random() * 12) + 's';
    petal.style.animationDelay = (Math.random() * 15) + 's';
    container.appendChild(petal);
  }

  // Ink drops — smaller, darker, round
  for (let i = 0; i < inkCount; i++) {
    const drop = document.createElement('div');
    drop.className = 'petal petal--ink';
    drop.style.width = '2px';
    drop.style.height = '2px';
    drop.style.backgroundColor = inkColors[Math.floor(Math.random() * inkColors.length)];
    drop.style.left = Math.random() * 100 + '%';
    drop.style.top = -10 + 'px';
    drop.style.animationDuration = (10 + Math.random() * 14) + 's';
    drop.style.animationDelay = (Math.random() * 18) + 's';
    container.appendChild(drop);
  }
}

function applySnapshot(snapshot) {
  if (!snapshot || !Array.isArray(snapshot.characters)) return;
  appState.order = snapshot.characters.map(char => char.name).filter(Boolean);
  appState.characters = new Map(
    snapshot.characters
      .filter(char => !!char?.name)
      .map(char => [char.name, normalizeCharacter(char)])
  );
  syncCards();
  maybeRefreshActiveModalFromSnapshot();
}

async function loadInitialSnapshot() {
  const base = window.__BASE_PATH__ || '';
  const res = await fetch(`${base}/api/ui/snapshot`, { cache: 'no-store' });
  if (!res.ok) throw new Error(`snapshot HTTP ${res.status}`);
  const snapshot = await res.json();
  applySnapshot(snapshot);
}

function connectLiveEvents() {
  if (eventSource) eventSource.close();
  const evtBase = window.__BASE_PATH__ || '';
  eventSource = new EventSource(`${evtBase}/api/ui/events`);

  eventSource.addEventListener('snapshot', (event) => {
    try {
      const snapshot = JSON.parse(event.data);
      applySnapshot(snapshot);
    } catch (err) {
      console.error('Could not parse snapshot event', err);
    }
  });

  eventSource.addEventListener('heartbeat', () => {
    // Connection keepalive marker, no UI action needed.
  });
}

/* ==============================================================
   INIT
   ============================================================== */
async function init() {
  setupModalFramework();
  await Promise.all([
    probeConfigFeatureAvailability(),
    probeControlFeatureAvailability(),
  ]);
  createPetals();

  try {
    await loadInitialSnapshot();
  } catch (err) {
    console.error('Failed to load initial snapshot', err);
  }

  connectLiveEvents();

  setInterval(() => {
    for (const name of appState.order) {
      const char = appState.characters.get(name);
      const refs = cardRefs.get(name);
      if (!char || !refs) continue;
      updateCooldown(refs, char);
    }
  }, 100);
}

window.addEventListener('beforeunload', () => {
  stopControlStatusPolling();
  if (controlState.actionController) {
    controlState.actionController.abort();
    controlState.actionController = null;
  }
  clearControlResetTimer();
});

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
